/*
 * Copyright (c) 2008-2016, GigaSpaces Technologies, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Generated By:JavaCC: Do not edit this line. SqlParser.java */
package com.j_spaces.jdbc.parser.grammar;

import com.j_spaces.core.client.TemplateMatchCodes;
import com.j_spaces.jdbc.AbstractDMLQuery;
import com.j_spaces.jdbc.AlterTableQuery;
import com.j_spaces.jdbc.CommitQuery;
import com.j_spaces.jdbc.CreateTableQuery;
import com.j_spaces.jdbc.DeleteQuery;
import com.j_spaces.jdbc.DropTableQuery;
import com.j_spaces.jdbc.InsertQuery;
import com.j_spaces.jdbc.OrderColumn;
import com.j_spaces.jdbc.ProcedureQuery;
import com.j_spaces.jdbc.Query;
import com.j_spaces.jdbc.QueryProcessor;
import com.j_spaces.jdbc.SelectColumn;
import com.j_spaces.jdbc.SelectQuery;
import com.j_spaces.jdbc.SqlConstants;
import com.j_spaces.jdbc.UpdateColumn;
import com.j_spaces.jdbc.UpdateQuery;
import com.j_spaces.jdbc.driver.Blob;
import com.j_spaces.jdbc.driver.Clob;
import com.j_spaces.jdbc.parser.AndNode;
import com.j_spaces.jdbc.parser.ColumnNode;
import com.j_spaces.jdbc.parser.ContainsItemNode;
import com.j_spaces.jdbc.parser.ContainsItemsRootNode;
import com.j_spaces.jdbc.parser.ContainsNode;
import com.j_spaces.jdbc.parser.EqualNode;
import com.j_spaces.jdbc.parser.ExpNode;
import com.j_spaces.jdbc.parser.GTENode;
import com.j_spaces.jdbc.parser.GTNode;
import com.j_spaces.jdbc.parser.InNode;
import com.j_spaces.jdbc.parser.InnerQueryNode;
import com.j_spaces.jdbc.parser.IsNullNode;
import com.j_spaces.jdbc.parser.LTENode;
import com.j_spaces.jdbc.parser.LTNode;
import com.j_spaces.jdbc.parser.LikeNode;
import com.j_spaces.jdbc.parser.LiteralNode;
import com.j_spaces.jdbc.parser.NotEqualNode;
import com.j_spaces.jdbc.parser.NotInNode;
import com.j_spaces.jdbc.parser.NotLikeNode;
import com.j_spaces.jdbc.parser.OrNode;
import com.j_spaces.jdbc.parser.PreparedNode;
import com.j_spaces.jdbc.parser.RLikeNode;
import com.j_spaces.jdbc.parser.RelationNode;
import com.j_spaces.jdbc.parser.RowNumNode;
import com.j_spaces.jdbc.parser.ValueNode;

import java.io.Reader;
import java.math.BigDecimal;
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashSet;
import java.util.Iterator;

@com.gigaspaces.api.InternalApi
public class SqlParser implements SqlParserConstants {

    private int conditionIndex = 0;

    // TOKEN_EXTENDS=com.j_spaces.jdbc.parser.SerializableToken
    public static void main(String[] args) throws ParseException {
        SqlParser parser = new SqlParser(System.in);
        while (true) {
            try {

                Query query = parser.parseStatement();
                System.out.println("Query received and parsed: ");
                System.out.println(query);
            } catch (Exception e) {
                System.err.println("Caught Exception - error in query");
                e.printStackTrace();
                parser.ReInit(System.in);
                System.exit(-1);
            }
        }
    }

    public void reset(Reader reader) {
        conditionIndex = 0;
        ReInit(reader);
    }

    // start statement methods
    final public Query parseStatement() throws ParseException {
        Query query;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SELECT:
                query = selectSql();
                break;
            case DELETE:
                query = deleteSql();
                break;
            case INSERT:
                query = insertSql();
                break;
            case UPDATE:
                query = updateSql();
                break;
            case CREATE:
                query = createTable();
                break;
            case DROP:
                query = dropTable();
                break;
            case ALTER:
                query = alterTable();
                break;
            case COMMIT:
            case ROLLBACK:
                query = commit();
                break;
            case CALL:
                query = executeProcedure();
                break;
            default:
                jj_la1[0] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SEMICOLON:
                jj_consume_token(SEMICOLON);
                break;
            case 0:
                jj_consume_token(0);
                break;
            default:
                jj_la1[1] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    /* statement methods */
    final public Query selectSql() throws ParseException {
        SelectQuery query;
        ExpNode exp = null;
        jj_consume_token(SELECT);
        query = new SelectQuery();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ALL:
            case DISTINCT:
                setQuantifier(query);
                break;
            default:
                jj_la1[2] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case OPENPAREN:
                jj_consume_token(OPENPAREN);
                break;
            default:
                jj_la1[3] = jj_gen;
                ;
        }
        selectColumnList(query);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CLOSEPAREN:
                jj_consume_token(CLOSEPAREN);
                break;
            default:
                jj_la1[4] = jj_gen;
                ;
        }
        jj_consume_token(FROM);
        selectTableList(query);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WHERE:
                jj_consume_token(WHERE);
                exp = SqlExpression(query);
                break;
            default:
                jj_la1[5] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case GROUP:
                groupBy(query);
                break;
            default:
                jj_la1[6] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ORDER:
                orderBy(query);
                break;
            default:
                jj_la1[7] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case FOR_UPDATE:
                jj_consume_token(FOR_UPDATE);
                query.setForUpdate(true);
                break;
            default:
                jj_la1[8] = jj_gen;
                ;
        }
        query.setExpTree(exp);
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    // handle SQLQuery syntax (no from clause)
    final public AbstractDMLQuery readMultipleQuery() throws ParseException {
        AbstractDMLQuery query;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CALL:
                query = executeProcedure();
                break;
            default:
                jj_la1[9] = jj_gen;
                query = selectSqlQuery();
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SEMICOLON:
                jj_consume_token(SEMICOLON);
                break;
            case 0:
                jj_consume_token(0);
                break;
            default:
                jj_la1[10] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    // handle SQLQuery syntax (no from clause)
    final public SelectQuery selectSqlQuery() throws ParseException {
        SelectQuery query = new SelectQuery();

        ExpNode exp = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ROWNUM:
            case IDENTIFIER:
            case ESC_IDENTIFIER:
            case OPENPAREN:
                exp = SqlExpression(query);
                break;
            default:
                jj_la1[11] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case GROUP:
                groupBy(query);
                break;
            default:
                jj_la1[12] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ORDER:
                orderBy(query);
                break;
            default:
                jj_la1[13] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case FOR_UPDATE:
                jj_consume_token(FOR_UPDATE);
                query.setForUpdate(true);
                break;
            default:
                jj_la1[14] = jj_gen;
                ;
        }
        SelectColumn selectC = new SelectColumn("*");
        query.addColumn(selectC);

        query.setExpTree(exp);
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    // handle SQLQuery syntax (no from clause)
    final public DeleteQuery deleteSqlQuery() throws ParseException {
        DeleteQuery query = new DeleteQuery();
        ExpNode exp = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ROWNUM:
            case IDENTIFIER:
            case ESC_IDENTIFIER:
            case OPENPAREN:
                exp = SqlExpression(query);
                break;
            default:
                jj_la1[15] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SEMICOLON:
                jj_consume_token(SEMICOLON);
                break;
            case 0:
                jj_consume_token(0);
                break;
            default:
                jj_la1[16] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        query.setExpTree(exp);
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    // handle SQLQuery syntax (no from clause)
    final public SelectQuery countSqlQuery() throws ParseException {
        SelectQuery query = new SelectQuery();
        ExpNode exp = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ROWNUM:
            case IDENTIFIER:
            case ESC_IDENTIFIER:
            case OPENPAREN:
                exp = SqlExpression(query);
                break;
            default:
                jj_la1[17] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case GROUP:
                groupBy(query);
                break;
            default:
                jj_la1[18] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ORDER:
                orderBy(query);
                break;
            default:
                jj_la1[19] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case FOR_UPDATE:
                jj_consume_token(FOR_UPDATE);
                query.setForUpdate(true);
                break;
            default:
                jj_la1[20] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SEMICOLON:
                jj_consume_token(SEMICOLON);
                break;
            case 0:
                jj_consume_token(0);
                break;
            default:
                jj_la1[21] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        SelectColumn selectC = new SelectColumn("*");
        selectC.setCount(true);
        selectC.setFunctionName(SqlConstants.COUNT);
        query.setAggFunction(true);
        query.addColumn(selectC);

        query.setExpTree(exp);
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    final public Query deleteSql() throws ParseException {
        DeleteQuery query;
        ExpNode exp = null;
        jj_consume_token(DELETE);
        query = new DeleteQuery();
        jj_consume_token(FROM);
        tableNameWithOptionalAlias(query);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WHERE:
                jj_consume_token(WHERE);
                exp = SqlExpression(query);
                break;
            default:
                jj_la1[22] = jj_gen;
                ;
        }
        query.setExpTree(exp);
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    final public Query updateSql() throws ParseException {
        UpdateQuery query;
        ExpNode exp = null;
        jj_consume_token(UPDATE);
        query = new UpdateQuery();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case BY:
                jj_consume_token(BY);
                jj_consume_token(UID);
                query.setByUid(true);
                break;
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                tableNameWithOptionalAlias(query);
                break;
            default:
                jj_la1[23] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        jj_consume_token(SET);
        columnListWithValues(query);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WHERE:
                jj_consume_token(WHERE);
                exp = SqlExpression(query);
                break;
            default:
                jj_la1[24] = jj_gen;
                ;
        }
        query.setExpTree(exp);
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    final public Query insertSql() throws ParseException {
        InsertQuery query;
        Query innerQuery = null;
        jj_consume_token(INSERT);
        query = new InsertQuery();
        jj_consume_token(INTO);
        tableName(query);
        if (jj_2_1(2)) {
            jj_consume_token(OPENPAREN);
            columnList(query);
            jj_consume_token(CLOSEPAREN);
        } else {
            ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case VALUES:
                jj_consume_token(VALUES);
                jj_consume_token(OPENPAREN);
                insertValuesList(query);
                jj_consume_token(CLOSEPAREN);
                break;
            case SELECT:
            case OPENPAREN:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case OPENPAREN:
                        jj_consume_token(OPENPAREN);
                        break;
                    default:
                        jj_la1[25] = jj_gen;
                        ;
                }
                innerQuery = selectSql();
                query.setQuery((SelectQuery) innerQuery);
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case CLOSEPAREN:
                        jj_consume_token(CLOSEPAREN);
                        break;
                    default:
                        jj_la1[26] = jj_gen;
                        ;
                }
                break;
            default:
                jj_la1[27] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    final public Query createTable() throws ParseException {
        CreateTableQuery query;
        Token column, PKName;
        String table, type;
        ArrayList columns;
        ArrayList types;
        ArrayList indices;
        int index = 0;
        jj_consume_token(CREATE);
        jj_consume_token(TABLE);
        query = new CreateTableQuery();
        table = className();
        query.setTableName(table);
        columns = new ArrayList();
        types = new ArrayList();
        indices = new ArrayList();
        jj_consume_token(OPENPAREN);
        column = id();
        String columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? column.image :
                column.image.toUpperCase();
        columns.add(columnName);
        type = sqlType();
        types.add(type);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case INDEX:
            case PRIMARY_KEY:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case PRIMARY_KEY:
                        jj_consume_token(PRIMARY_KEY);
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case NOT:
                                jj_consume_token(NOT);
                                jj_consume_token(NULL);
                                break;
                            default:
                                jj_la1[28] = jj_gen;
                                ;
                        }
                        break;
                    case INDEX:
                        jj_consume_token(INDEX);
                        break;
                    default:
                        jj_la1[29] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                indices.add(new Integer(index));
                break;
            default:
                jj_la1[30] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case DEFAULT_NULL:
                jj_consume_token(DEFAULT_NULL);
                break;
            default:
                jj_la1[31] = jj_gen;
                ;
        }
        label_1:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 125:
                    ;
                    break;
                default:
                    jj_la1[32] = jj_gen;
                    break label_1;
            }
            jj_consume_token(125);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PRIMARY_KEY:
                    jj_consume_token(PRIMARY_KEY);
                    jj_consume_token(OPENPAREN);
                    PKName = id();
                    for (int i = 0; i < columns.size(); i++) {
                        if (PKName.image.equalsIgnoreCase((String) (columns.get(i)))) {
                            indices.add(new Integer(i));
                            break;
                        }
                    }
                    label_2:
                    while (true) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case 125:
                                ;
                                break;
                            default:
                                jj_la1[33] = jj_gen;
                                break label_2;
                        }
                        jj_consume_token(125);
                        PKName = id();
                        for (int i = 0; i < columns.size(); i++) {
                            if (PKName.image.equalsIgnoreCase((String) (columns.get(i)))) {
                                indices.add(new Integer(i));
                                break;
                            }
                        }
                    }
                    jj_consume_token(CLOSEPAREN);
                    break;
                case PARTITION_BY:
                    jj_consume_token(PARTITION_BY);
                    jj_consume_token(OPENPAREN);
                    column = id();
                    if (query.getRoutingFieldName() != null) {
                        if (true)
                            throw new ParseException("PARTITION BY can only be set for one column!");
                    }
                    columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? column.image :
                            column.image.toUpperCase();
                    query.setRoutingFieldName(columnName);
                    jj_consume_token(CLOSEPAREN);
                    break;
                case IDENTIFIER:
                case ESC_IDENTIFIER:
                    column = id();
                    columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? column.image :
                            column.image.toUpperCase();
                    columns.add(columnName);
                    type = sqlType();
                    types.add(type);
                    index++;
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case INDEX:
                        case PRIMARY_KEY:
                            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                case PRIMARY_KEY:
                                    jj_consume_token(PRIMARY_KEY);
                                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                        case NOT:
                                            jj_consume_token(NOT);
                                            jj_consume_token(NULL);
                                            break;
                                        default:
                                            jj_la1[34] = jj_gen;
                                            ;
                                    }
                                    break;
                                case INDEX:
                                    jj_consume_token(INDEX);
                                    break;
                                default:
                                    jj_la1[35] = jj_gen;
                                    jj_consume_token(-1);
                                    throw new ParseException();
                            }
                            indices.add(new Integer(index));
                            break;
                        default:
                            jj_la1[36] = jj_gen;
                            ;
                    }
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case DEFAULT_NULL:
                            jj_consume_token(DEFAULT_NULL);
                            break;
                        default:
                            jj_la1[37] = jj_gen;
                            ;
                    }
                    break;
                default:
                    jj_la1[38] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        jj_consume_token(CLOSEPAREN);
        String[] namesArray = new String[columns.size()];
        String[] typesArray = new String[types.size()];
        boolean[] indicesArray = new boolean[types.size()];
        Iterator it = indices.iterator();
        while (it.hasNext()) {
            indicesArray[((Integer) it.next()).intValue()] = true;
        }
        query.setColumnNames((String[]) columns.toArray(namesArray));
        query.setColumnTypes((String[]) types.toArray(typesArray));
        query.setIndices(indicesArray);
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    final public Query dropTable() throws ParseException {
        DropTableQuery query;
        String table;
        jj_consume_token(DROP);
        jj_consume_token(TABLE);
        query = new DropTableQuery();
        table = className();
        query.setTableName(table);
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    final public Query alterTable() throws ParseException {
        AlterTableQuery query;
        Token index;
        String table;
        ArrayList columns;
        jj_consume_token(ALTER);
        jj_consume_token(TABLE);
        query = new AlterTableQuery();
        table = className();
        query.setTableName(table);
        jj_consume_token(ADD);
        jj_consume_token(PRIMARY_KEY);
        jj_consume_token(OPENPAREN);
        columns = new ArrayList();
        index = id();
        String columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? index.image :
                index.image.toUpperCase();
        columns.add(columnName);
        label_3:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 125:
                    ;
                    break;
                default:
                    jj_la1[39] = jj_gen;
                    break label_3;
            }
            jj_consume_token(125);
            index = id();
            columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? index.image :
                    index.image.toUpperCase();
            columns.add(columnName);
        }
        jj_consume_token(CLOSEPAREN);
        jj_consume_token(USING);
        jj_consume_token(INDEX);
        String[] names = new String[columns.size()];
        query.setIndices((String[]) columns.toArray(names));
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    final public Query commit() throws ParseException {
        CommitQuery query;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case COMMIT:
                jj_consume_token(COMMIT);
                query = new CommitQuery(true);
                break;
            case ROLLBACK:
                jj_consume_token(ROLLBACK);
                query = new CommitQuery(false);
                break;
            default:
                jj_la1[40] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

    final public ProcedureQuery executeProcedure() throws ParseException {
        ProcedureQuery query = null;
        Token procedure, parameter;
        String negative = "";
        ArrayList parmList = new ArrayList();
        ;
        jj_consume_token(CALL);
        query = new ProcedureQuery();
        procedure = id();
        String procName = procedure.image;
        query.setProcName(procName);
        jj_consume_token(OPENPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
            case ESC_IDENTIFIER:
            case INTEGER_LITERAL:
            case LONG_LITERAL:
            case FLOATING_POINT_LITERAL:
            case STRING_LITERAL:
            case QUESTIONMARK:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case STRING_LITERAL:
                        parameter = jj_consume_token(STRING_LITERAL);
                        String parameterName = parameter.image;
                        query.addParamList(parameterName);
                        break;
                    case INTEGER_LITERAL:
                        parameter = jj_consume_token(INTEGER_LITERAL);
                        query.addParamList(new Integer(parameter.image));
                        break;
                    case LONG_LITERAL:
                        parameter = jj_consume_token(LONG_LITERAL);
                        query.addParamList(new Long(parameter.image.substring(0, parameter.image.length() - 1)));
                        break;
                    case FLOATING_POINT_LITERAL:
                        parameter = jj_consume_token(FLOATING_POINT_LITERAL);
                        query.addParamList(new Float(parameter.image));
                        negative = "";
                        break;
                    case IDENTIFIER:
                    case ESC_IDENTIFIER:
                        parameter = id();
                        query.addParamList(procedure.image);
                        break;
                    case QUESTIONMARK:
                        parameter = jj_consume_token(QUESTIONMARK);
                        query.setPrepared(true);
                        query.addParamList(null);
                        ++conditionIndex;
                        break;
                    default:
                        jj_la1[41] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                label_4:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case 125:
                            ;
                            break;
                        default:
                            jj_la1[42] = jj_gen;
                            break label_4;
                    }
                    jj_consume_token(125);
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case STRING_LITERAL:
                            parameter = jj_consume_token(STRING_LITERAL);
                            String parameterName = parameter.image;
                            query.addParamList(parameterName);
                            break;
                        case INTEGER_LITERAL:
                            parameter = jj_consume_token(INTEGER_LITERAL);
                            query.addParamList(new Integer(parameter.image));
                            negative = "";
                            break;
                        case LONG_LITERAL:
                            parameter = jj_consume_token(LONG_LITERAL);
                            query.addParamList(new Long(parameter.image.substring(0, parameter.image.length() - 1)));
                            break;
                        case FLOATING_POINT_LITERAL:
                            parameter = jj_consume_token(FLOATING_POINT_LITERAL);
                            query.addParamList(new Float(parameter.image));
                            negative = "";
                            break;
                        case IDENTIFIER:
                        case ESC_IDENTIFIER:
                            parameter = id();
                            query.addParamList(procedure.image);
                            break;
                        case QUESTIONMARK:
                            parameter = jj_consume_token(QUESTIONMARK);
                            query.setPrepared(true);
                            query.addParamList(null);
                            ++conditionIndex;
                            break;
                        default:
                            jj_la1[43] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                }
                break;
            default:
                jj_la1[44] = jj_gen;
                ;
        }
        jj_consume_token(CLOSEPAREN);
        {
            if (true) return query;
        }
        throw new Error("Missing return statement in function");
    }

/* specific clause methods */

    //check for the distinct
    final public void setQuantifier(SelectQuery query) throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case DISTINCT:
                jj_consume_token(DISTINCT);
                query.setDistinct(true);
                break;
            case ALL:
                jj_consume_token(ALL);
                query.setDistinct(false);
                break;
            default:
                jj_la1[45] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    //retrieve a list of columns that are seperated by a comma
    final public void columnList(AbstractDMLQuery query) throws ParseException {
        Token column = null;
        column = id();
        String columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? column.image :
                column.image.toUpperCase();
        query.addColumn(columnName);
        label_5:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 125:
                    ;
                    break;
                default:
                    jj_la1[46] = jj_gen;
                    break label_5;
            }
            jj_consume_token(125);
            column = id();
            columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? column.image :
                    column.image.toUpperCase();
            query.addColumn(columnName);
        }
    }

    //retrieve a list of columns that are seperated by a comma for a select Query
    final public void selectColumnList(SelectQuery query) throws ParseException {
        Token column = null;
        Token value = null;
        SelectColumn selectC = null;
        if (jj_2_2(2)) {
            id();
            jj_consume_token(DOT);
        } else {
            ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case UID:
            case IDENTIFIER:
            case ESC_IDENTIFIER:
            case STRING_LITERAL:
            case ASTERISK:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case IDENTIFIER:
                    case ESC_IDENTIFIER:
                        selectC = getSelectColumn(query);
                        break;
                    case ASTERISK:
                        jj_consume_token(ASTERISK);
                        selectC = new SelectColumn("*");
                        break;
                    case UID:
                        jj_consume_token(UID);
                        selectC = new SelectColumn("UID");
                        break;
                    case STRING_LITERAL:
                        value = jj_consume_token(STRING_LITERAL);
                        selectC = getSelectColumn(query);
                        selectC.setValue(value.image);
                        break;
                    default:
                        jj_la1[47] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                if (selectC != null) {
                    query.addColumn(selectC);
                }
                break;
            default:
                jj_la1[48] = jj_gen;
                if (jj_2_3(2)) {
                    function((SelectQuery) query);
                } else {
                    jj_consume_token(-1);
                    throw new ParseException();
                }
        }
        label_6:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 125:
                    ;
                    break;
                default:
                    jj_la1[49] = jj_gen;
                    break label_6;
            }
            jj_consume_token(125);
            if (jj_2_4(2)) {
                id();
                jj_consume_token(DOT);
            } else {
                ;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case UID:
                case IDENTIFIER:
                case ESC_IDENTIFIER:
                case STRING_LITERAL:
                case ASTERISK:
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case IDENTIFIER:
                        case ESC_IDENTIFIER:
                            selectC = getSelectColumn(query);
                            break;
                        case ASTERISK:
                            jj_consume_token(ASTERISK);
                            selectC = new SelectColumn("*");
                            break;
                        case UID:
                            jj_consume_token(UID);
                            selectC = new SelectColumn("UID");
                            break;
                        case STRING_LITERAL:
                            value = jj_consume_token(STRING_LITERAL);
                            selectC = getSelectColumn(query);
                            selectC.setValue(value.image);
                            break;
                        default:
                            jj_la1[50] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    if (selectC != null) {
                        query.addColumn(selectC);
                    }
                    break;
                default:
                    jj_la1[51] = jj_gen;
                    if (jj_2_5(2)) {
                        function((SelectQuery) query);
                    } else {
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
            }
        }
        query.addAbsentCol();
    }

    final public void columnListWithValues(UpdateQuery query) throws ParseException {
        ArrayList<LiteralNode> newValues = new ArrayList<LiteralNode>();
        setColumnValue(query, newValues);
        label_7:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 125:
                    ;
                    break;
                default:
                    jj_la1[52] = jj_gen;
                    break label_7;
            }
            jj_consume_token(125);
            setColumnValue(query, newValues);
        }
        query.setUpdatedValues(newValues);
    }

    final public void setColumnValue(UpdateQuery updateQuery, ArrayList<LiteralNode> newValues) throws ParseException {
        Token column, newValue;
        String negative = "";
        UpdateColumn updateColumn = null;
        Token selfIncrementedColumn;
        column = id();
        String columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? column.image : column.image.toUpperCase();
        updateColumn = new UpdateColumn(columnName);
        updateQuery.addUpdateColumn(updateColumn);
        jj_consume_token(EQUAL);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case MINUS:
                jj_consume_token(MINUS);
                negative = "-";
                break;
            default:
                jj_la1[53] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case QUESTIONMARK:
                newValue = jj_consume_token(QUESTIONMARK);
                updateQuery.setPrepared(true);
                newValues.add(new PreparedNode(null));
                ++conditionIndex;
                break;
            case STRING_LITERAL:
                newValue = jj_consume_token(STRING_LITERAL);
                newValues.add(new LiteralNode(newValue.image.substring(1, newValue.image.length() - 1)));
                break;
            case INTEGER_LITERAL:
                newValue = jj_consume_token(INTEGER_LITERAL);
                newValues.add(new LiteralNode(negative + newValue.image));
                break;
            case LONG_LITERAL:
                newValue = jj_consume_token(LONG_LITERAL);
                newValues.add(new LiteralNode(negative + newValue.image.substring(0, newValue.image.length() - 1)));
                break;
            case FLOATING_POINT_LITERAL:
                newValue = jj_consume_token(FLOATING_POINT_LITERAL);
                newValues.add(new LiteralNode(negative + newValue.image));
                break;
            case TRUE:
                jj_consume_token(TRUE);
                newValues.add(new LiteralNode(Boolean.TRUE));
                break;
            case FALSE:
                jj_consume_token(FALSE);
                newValues.add(new LiteralNode(Boolean.FALSE));
                break;
            case EMPTY_CLOB:
                jj_consume_token(EMPTY_CLOB);
                newValues.add(new LiteralNode(new Clob("")));
                break;
            case EMPTY_BLOB:
                jj_consume_token(EMPTY_BLOB);
                newValues.add(new LiteralNode(new Blob(new byte[0])));
                break;
            case NULL:
                jj_consume_token(NULL);
                newValues.add(new LiteralNode(null));
                break;
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                selfIncrementedColumn = id();
                columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ?
                        selfIncrementedColumn.image : selfIncrementedColumn.image.toUpperCase();
                updateColumn.setSelfIncrementedColumnName(columnName);
                updateQuery.setSelfIncrementedUpdateColumn(true);
                jj_consume_token(PLUS);
                newValue = jj_consume_token(INTEGER_LITERAL);
                newValues.add(new LiteralNode(negative + newValue.image));
                break;
            default:
                jj_la1[54] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    final public void function(SelectQuery query) throws ParseException {
        Token token = null;
        SelectColumn selectC = null;
        String alias = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SUM:
                jj_consume_token(SUM);
                selectC = new SelectColumn();
                selectC.setSum(true);
                selectC.setFunctionName(SqlConstants.SUM);
                query.setAggFunction(true);
                break;
            case COUNT:
                jj_consume_token(COUNT);
                selectC = new SelectColumn();
                selectC.setCount(true);
                selectC.setFunctionName(SqlConstants.COUNT);
                query.setAggFunction(true);
                break;
            case MAX:
                jj_consume_token(MAX);
                selectC = new SelectColumn();
                selectC.setFunctionName(SqlConstants.MAX);
                query.setAggFunction(true);
                break;
            case MIN:
                jj_consume_token(MIN);
                selectC = new SelectColumn();
                selectC.setFunctionName(SqlConstants.MIN);
                query.setAggFunction(true);
                break;
            case AVG:
                jj_consume_token(AVG);
                selectC = new SelectColumn();
                selectC.setFunctionName(SqlConstants.AVG);
                query.setAggFunction(true);
                break;
            default:
                jj_la1[55] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        jj_consume_token(OPENPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ASTERISK:
                jj_consume_token(ASTERISK);
                selectC.setName("*");
                query.addColumn(selectC);
                break;
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                token = id();
                String id = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? token.image : token.image.toUpperCase();

                selectC.setName(id);
                query.addColumn(selectC);
                break;
            default:
                jj_la1[56] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        jj_consume_token(CLOSEPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case AS:
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case AS:
                        jj_consume_token(AS);
                        break;
                    default:
                        jj_la1[57] = jj_gen;
                        ;
                }
                token = id();
                selectC.setAlias(token.image);
                break;
            default:
                jj_la1[58] = jj_gen;
                ;
        }
    }

    /*

ColumnNode createColumnNode(AbstractDMLQuery query,String columnFunc):
{
 String table = null;
 String columnName = null;
 ColumnNode columnNode = null;
 Token t, function = null;
 }
 {
    LOOKAHEAD(2) function = <IDENTIFIER> <OPENPAREN> t = id()  <CLOSEPAREN> {
        String id =  (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? t.image : t.image.toUpperCase();
        columnNode = new ColumnNode(id);
        columnNode.setFunctionName(function.image);
        return columnNode;
    }
 	|(t = id() {
    	 String id =  (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? t.image : t.image.toUpperCase();
    	 columnNode = new ColumnNode(id);
    })

    {return columnNode;}
}

*/
    final public ColumnNode createColumnNode(AbstractDMLQuery query, String columnFunc) throws ParseException {
        String table = null;
        String columnName = null;
        ColumnNode columnNode = null;
        Token t, function = null;
        java.util.List params;
        if (jj_2_6(2)) {
            function = jj_consume_token(IDENTIFIER);
            jj_consume_token(OPENPAREN);
            params = createFunctionParams();
            jj_consume_token(CLOSEPAREN);
            java.util.List args = new java.util.ArrayList();
            int pos = 0;
            int columnIndex = 0;
            for (Object p : params) {
                if (p instanceof ColumnNode) {
                    if (columnNode == null) {
                        args.add(null);
                        columnNode = (ColumnNode) p;
                        columnIndex = pos;
                    } else {
                        {
                            if (true)
                                throw new ParseException("More then one column in function call " + function.image + " call " + columnNode + " " + p);
                        }
                    }
                } else {
                    args.add(p);
                }
                pos += 1;
            }
            if (columnNode == null) {
                {
                    if (true)
                        throw new ParseException("Missing column in function call " + function.image);
                }
            }
            columnNode.setFunctionCallDescription(new com.j_spaces.jdbc.builder.range.FunctionCallDescription(function.image, columnIndex, args));
            {
                if (true) return columnNode;
            }
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IDENTIFIER:
                case ESC_IDENTIFIER:
                    t = id();
                    String id = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? t.image : t.image.toUpperCase();
                    columnNode = new ColumnNode(id);
                {
                    if (true) return columnNode;
                }
                break;
                default:
                    jj_la1[59] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public java.util.List createFunctionParams() throws ParseException {
        java.util.List params = new java.util.ArrayList();
        Object param;
        param = param();
        params.add(param);
        label_8:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 125:
                    ;
                    break;
                default:
                    jj_la1[60] = jj_gen;
                    break label_8;
            }
            jj_consume_token(125);
            param = param();
            params.add(param);
        }
        {
            if (true) return params;
        }
        throw new Error("Missing return statement in function");
    }

    final public Object param() throws ParseException {
        Token parameter;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case STRING_LITERAL:
                parameter = jj_consume_token(STRING_LITERAL);
            {
                if (true)
                    return new String(parameter.image.substring(1, parameter.image.length() - 1));
            }
            break;
            case INTEGER_LITERAL:
                parameter = jj_consume_token(INTEGER_LITERAL);
            {
                if (true) return new Integer(parameter.image);
            }
            break;
            case LONG_LITERAL:
                parameter = jj_consume_token(LONG_LITERAL);
            {
                if (true)
                    return new Long(parameter.image.substring(0, parameter.image.length() - 1));
            }
            break;
            case FLOATING_POINT_LITERAL:
                parameter = jj_consume_token(FLOATING_POINT_LITERAL);
            {
                if (true) return (new Float(parameter.image));
            }
            break;
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                parameter = id();
                String id = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? parameter.image : parameter.image.toUpperCase();
            {
                if (true) return new ColumnNode(id);
            }
            break;
            default:
                jj_la1[61] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    //retrieve a list of tables in a select query
    final public void selectTableList(SelectQuery query) throws ParseException {
        String table = null;
        Token alias = null;
        table = className();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                alias = id();
                break;
            default:
                jj_la1[62] = jj_gen;
                ;
        }
        query.addTableWithAlias(table, ((alias == null) ? null : alias.image));
        alias = null;
        label_9:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 125:
                    ;
                    break;
                default:
                    jj_la1[63] = jj_gen;
                    break label_9;
            }
            jj_consume_token(125);
            table = className();
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IDENTIFIER:
                case ESC_IDENTIFIER:
                    alias = id();
                    break;
                default:
                    jj_la1[64] = jj_gen;
                    ;
            }
            query.addTableWithAlias(table, ((alias == null) ? null : alias.image));
            alias = null;
        }
    }

    final public void tableNameWithOptionalAlias(AbstractDMLQuery query) throws ParseException {
        String tableName = null;
        Token tableAlias = null;
        tableName = className();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                tableAlias = id();
                break;
            default:
                jj_la1[65] = jj_gen;
                ;
        }
        query.addTableWithAlias(tableName, ((tableAlias == null) ? null : tableAlias.image));
    }

    final public void tableName(AbstractDMLQuery query) throws ParseException {
        String table = null;
        table = className();
        query.setTableName(table);
    }

    final public void insertValuesList(InsertQuery insertQuery) throws ParseException {
        Token t = null;
        String negative = "";
        ArrayList<LiteralNode> list = new ArrayList<LiteralNode>();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case QUESTIONMARK:
                t = jj_consume_token(QUESTIONMARK);
                insertQuery.setPrepared(true);
                list.add(new PreparedNode(null));
                break;
            case TRUE:
                jj_consume_token(TRUE);
                list.add(new LiteralNode(Boolean.TRUE));
                break;
            case FALSE:
                jj_consume_token(FALSE);
                list.add(new LiteralNode(Boolean.FALSE));
                break;
            case NULL:
                jj_consume_token(NULL);
                list.add(new LiteralNode(null));
                break;
            case EMPTY_CLOB:
                jj_consume_token(EMPTY_CLOB);
                list.add(new LiteralNode(new Clob("")));
                break;
            case EMPTY_BLOB:
                jj_consume_token(EMPTY_BLOB);
                list.add(new LiteralNode(new Blob(new byte[0])));
                break;
            case STRING_LITERAL:
                t = jj_consume_token(STRING_LITERAL);
                list.add(new LiteralNode(new String(t.image.substring(1, t.image.length() - 1))));
                break;
            default:
                jj_la1[69] = jj_gen;
                if (jj_2_7(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[66] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(INTEGER_LITERAL);
                    list.add(new LiteralNode(negative + t.image));
                } else if (jj_2_8(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[67] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(LONG_LITERAL);
                    list.add(new LiteralNode(negative + t.image.substring(0, t.image.length() - 1)));
                } else if (jj_2_9(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[68] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(FLOATING_POINT_LITERAL);
                    list.add(new LiteralNode(negative + t.image));
                } else {
                    jj_consume_token(-1);
                    throw new ParseException();
                }
        }
        negative = "";
        label_10:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 125:
                    ;
                    break;
                default:
                    jj_la1[70] = jj_gen;
                    break label_10;
            }
            jj_consume_token(125);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case QUESTIONMARK:
                    t = jj_consume_token(QUESTIONMARK);
                    insertQuery.setPrepared(true);
                    list.add(new PreparedNode(null));
                    break;
                case TRUE:
                    jj_consume_token(TRUE);
                    list.add(new LiteralNode(Boolean.TRUE));
                    break;
                case FALSE:
                    jj_consume_token(FALSE);
                    list.add(new LiteralNode(Boolean.FALSE));
                    break;
                case NULL:
                    jj_consume_token(NULL);
                    list.add(new LiteralNode(null));
                    break;
                case EMPTY_CLOB:
                    jj_consume_token(EMPTY_CLOB);
                    list.add(new LiteralNode(new Clob("")));
                    break;
                case EMPTY_BLOB:
                    jj_consume_token(EMPTY_BLOB);
                    list.add(new LiteralNode(new Blob(new byte[0])));
                    break;
                case STRING_LITERAL:
                    t = jj_consume_token(STRING_LITERAL);
                    list.add(new LiteralNode(new String(t.image.substring(1, t.image.length() - 1))));
                    break;
                default:
                    jj_la1[74] = jj_gen;
                    if (jj_2_10(2)) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case MINUS:
                                jj_consume_token(MINUS);
                                negative = "-";
                                break;
                            default:
                                jj_la1[71] = jj_gen;
                                ;
                        }
                        t = jj_consume_token(INTEGER_LITERAL);
                        list.add(new LiteralNode(negative + t.image));
                    } else if (jj_2_11(2)) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case MINUS:
                                jj_consume_token(MINUS);
                                negative = "-";
                                break;
                            default:
                                jj_la1[72] = jj_gen;
                                ;
                        }
                        t = jj_consume_token(LONG_LITERAL);
                        list.add(new LiteralNode(negative + t.image.substring(0, t.image.length() - 1)));
                    } else if (jj_2_12(2)) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case MINUS:
                                jj_consume_token(MINUS);
                                negative = "-";
                                break;
                            default:
                                jj_la1[73] = jj_gen;
                                ;
                        }
                        t = jj_consume_token(FLOATING_POINT_LITERAL);
                        list.add(new LiteralNode(negative + t.image));
                    } else {
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
            }
            negative = "";
        }
        insertQuery.setValues(list);
    }

    final public void groupBy(SelectQuery query) throws ParseException {
        SelectColumn groupColumn = null;
        ArrayList list = new ArrayList();
        jj_consume_token(GROUP);
        jj_consume_token(BY);
        groupColumn = getSelectColumn(query);
        list.add(groupColumn);
        label_11:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 125:
                    ;
                    break;
                default:
                    jj_la1[75] = jj_gen;
                    break label_11;
            }
            jj_consume_token(125);
            groupColumn = getSelectColumn(query);
            list.add(groupColumn);
        }
        query.setGroupColumn(list);
    }

    final public void orderBy(SelectQuery query) throws ParseException {
        Token column = null;
        OrderColumn orderColumn = null;
        ArrayList list = new ArrayList();
        jj_consume_token(ORDER);
        jj_consume_token(BY);
        orderColumn = createOrderColumn(query);
        list.add(orderColumn);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ASC:
            case DESC:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case ASC:
                        jj_consume_token(ASC);
                        orderColumn.setDesc(false);
                        break;
                    case DESC:
                        jj_consume_token(DESC);
                        orderColumn.setDesc(true);
                        break;
                    default:
                        jj_la1[76] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[77] = jj_gen;
                ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NULLS_LAST:
            case NULLS_FIRST:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case NULLS_LAST:
                        jj_consume_token(NULLS_LAST);
                        orderColumn.setNullsLast(true);
                        break;
                    case NULLS_FIRST:
                        jj_consume_token(NULLS_FIRST);
                        orderColumn.setNullsLast(false);
                        break;
                    default:
                        jj_la1[78] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[79] = jj_gen;
                ;
        }
        label_12:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 125:
                    ;
                    break;
                default:
                    jj_la1[80] = jj_gen;
                    break label_12;
            }
            jj_consume_token(125);
            orderColumn = createOrderColumn(query);
            list.add(orderColumn);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case ASC:
                case DESC:
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case ASC:
                            jj_consume_token(ASC);
                            orderColumn.setDesc(false);
                            break;
                        case DESC:
                            jj_consume_token(DESC);
                            orderColumn.setDesc(true);
                            break;
                        default:
                            jj_la1[81] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    break;
                default:
                    jj_la1[82] = jj_gen;
                    ;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NULLS_LAST:
                case NULLS_FIRST:
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case NULLS_LAST:
                            jj_consume_token(NULLS_LAST);
                            orderColumn.setNullsLast(true);
                            break;
                        case NULLS_FIRST:
                            jj_consume_token(NULLS_FIRST);
                            orderColumn.setNullsLast(false);
                            break;
                        default:
                            jj_la1[83] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    break;
                default:
                    jj_la1[84] = jj_gen;
                    ;
            }
        }
        query.setOrderColumns(list);
    }

    final public OrderColumn createOrderColumn(AbstractDMLQuery query) throws ParseException {
        String id = null;
        SelectColumn col = null;
        Token t = null;
        String alias = null;
        t = id();
        id = QueryProcessor.getDefaultConfig().isParserCaseSensitivity() ? t.image : t.image.toUpperCase();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case AS:
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case AS:
                        jj_consume_token(AS);
                        break;
                    default:
                        jj_la1[85] = jj_gen;
                        ;
                }
                t = id();
                alias = t.image;
                break;
            default:
                jj_la1[86] = jj_gen;
                ;
        }
        {
            if (true) return new OrderColumn(id, alias);
        }
        throw new Error("Missing return statement in function");
    }

    final public SelectColumn getSelectColumn(AbstractDMLQuery query) throws ParseException {
        String id = null;
        SelectColumn col = null;
        Token t = null;
        String alias = null;
        t = id();
        id = QueryProcessor.getDefaultConfig().isParserCaseSensitivity() ? t.image : t.image.toUpperCase();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case AS:
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case AS:
                        jj_consume_token(AS);
                        break;
                    default:
                        jj_la1[87] = jj_gen;
                        ;
                }
                t = id();
                alias = t.image;
                break;
            default:
                jj_la1[88] = jj_gen;
                ;
        }
        col = new SelectColumn(id, alias);
        {
            if (true) return col;
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode SqlExpression(AbstractDMLQuery query) throws ParseException {
        ExpNode exp1;
        ExpNode exp2;
        exp1 = SqlAndExpression(query);
        label_13:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case OR:
                    ;
                    break;
                default:
                    jj_la1[89] = jj_gen;
                    break label_13;
            }
            jj_consume_token(OR);
            exp2 = SqlAndExpression(query);
            exp1 = new OrNode(exp1, exp2);
        }
        {
            if (true) return exp1;
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode SqlAndExpression(AbstractDMLQuery query) throws ParseException {
        ExpNode exp1;
        ExpNode exp2;
        exp1 = SqlSimpleExpression(query);
        label_14:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case AND:
                    ;
                    break;
                default:
                    jj_la1[90] = jj_gen;
                    break label_14;
            }
            jj_consume_token(AND);
            exp2 = SqlSimpleExpression(query);
            exp1 = new AndNode(exp1, exp2);
        }
        {
            if (true) return exp1;
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode SqlSimpleExpression(AbstractDMLQuery query) throws ParseException {
        ExpNode exp;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ROWNUM:
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                exp = condition(query);
                break;
            case OPENPAREN:
                jj_consume_token(OPENPAREN);
                exp = SqlExpression(query);
                jj_consume_token(CLOSEPAREN);
                break;
            default:
                jj_la1[91] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return exp;
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode SqlContainsItemExpression(AbstractDMLQuery query) throws ParseException {
        ExpNode exp1;
        ExpNode exp2;
        exp1 = SqlContainsItemSimpleExpression(query);
        label_15:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case AND:
                    ;
                    break;
                default:
                    jj_la1[92] = jj_gen;
                    break label_15;
            }
            jj_consume_token(AND);
            exp2 = SqlContainsItemSimpleExpression(query);
            exp1 = new AndNode(exp1, exp2);
        }
        {
            if (true) return exp1;
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode SqlContainsItemSimpleExpression(AbstractDMLQuery query) throws ParseException {
        ExpNode exp;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ROWNUM:
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                exp = containtsItemSimpleCondition(query);
                break;
            case OPENPAREN:
                jj_consume_token(OPENPAREN);
                exp = SqlContainsItemSimpleExpression(query);
                jj_consume_token(CLOSEPAREN);
                break;
            default:
                jj_la1[93] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return exp;
        }
        throw new Error("Missing return statement in function");
    }

    //handle one condition insinde contains, NOTE-currently no nested contains
    final public ExpNode containtsItemSimpleCondition(AbstractDMLQuery query) throws ParseException {
        Token t, table1 = null, table2 = null, addup = null, operator = null;
        ColumnNode columnNode1 = null, columnNode2 = null;

        ValueNode valueNode = null;
        String negative = "";
        ExpNode expNode = null;
        Token startIndex, endIndex;
        short templateMatchCode = TemplateMatchCodes.EQ;
        StringBuilder columnPath = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ROWNUM:
                jj_consume_token(ROWNUM);
            {
                if (true) throw new ParseException("ROWNUM not supported inside contains");
            }
            break;
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                columnNode1 = createColumnNode(query, null);

                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COLLECTION_CONTAINS:
                        jj_consume_token(COLLECTION_CONTAINS);
                        query.setContainsQuery(true);
                        columnPath = new StringBuilder(columnNode1.toString());
                        columnPath.append("[*]");
                        label_16:
                        while (true) {
                            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                case COLLECTION_CONTAINS:
                                    ;
                                    break;
                                default:
                                    jj_la1[94] = jj_gen;
                                    break label_16;
                            }
                            jj_consume_token(COLLECTION_CONTAINS);
                            columnPath.append("[*]");
                        }
                        label_17:
                        while (true) {
                            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                case DOT:
                                    ;
                                    break;
                                default:
                                    jj_la1[95] = jj_gen;
                                    break label_17;
                            }
                            jj_consume_token(DOT);
                            t = id();
                            String columnNameSuffix = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? t.image : t.image.toUpperCase();
                            columnPath.append(".");
                            columnPath.append(columnNameSuffix);
                            label_18:
                            while (true) {
                                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                    case COLLECTION_CONTAINS:
                                        ;
                                        break;
                                    default:
                                        jj_la1[96] = jj_gen;
                                        break label_18;
                                }
                                jj_consume_token(COLLECTION_CONTAINS);
                                columnPath.append("[*]");
                            }
                        }
                        expNode = containtsItemSimpleConditionImpl(query, columnPath, columnNode1, true);
                        break;
                    case BETWEEN:
                    case IN:
                    case LIKE:
                    case NOT:
                    case LESS:
                    case LESSEQUAL:
                    case GREATER:
                    case GREATEREQUAL:
                    case EQUAL:
                    case NOTEQUAL:
                    case NOTEQUAL2:
                    case OPENPAREN:
                        expNode = containtsItemSimpleConditionImpl(query, columnPath, columnNode1, false);
                        break;
                    default:
                        jj_la1[97] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            {
                if (true) return expNode;
            }
            break;
            default:
                jj_la1[98] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    //handle one condition inside contains
    final public ExpNode containtsItemSimpleConditionImpl(AbstractDMLQuery query, StringBuilder columnPath, ColumnNode columnNode1, boolean insideInternalContains) throws ParseException {
        ExpNode expNode = null;
        if (jj_2_13(2)) {
            expNode = containsInItemNode(query, columnNode1, columnPath);
        } else if (jj_2_14(2)) {
            expNode = containsBetweenItemNode(query, columnNode1, columnPath);
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LIKE:
                case NOT:
                case LESS:
                case LESSEQUAL:
                case GREATER:
                case GREATEREQUAL:
                case EQUAL:
                case NOTEQUAL:
                case NOTEQUAL2:
                case OPENPAREN:
                    expNode = containsSimpleItemNode(query, columnNode1, columnPath, insideInternalContains);
                    break;
                default:
                    jj_la1[99] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        {
            if (true) return expNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode SqlInClause(AbstractDMLQuery query) throws ParseException {
        ExpNode exp;
        boolean notIn = false;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NOT:
                jj_consume_token(NOT);
                notIn = true;
                break;
            default:
                jj_la1[100] = jj_gen;
                ;
        }
        jj_consume_token(IN);
        jj_consume_token(OPENPAREN);
        exp = inExprOrList(query, notIn);
        jj_consume_token(CLOSEPAREN);
        {
            if (true) return exp;
        }
        throw new Error("Missing return statement in function");
    }

    final public String className() throws ParseException {
        StringBuffer buffer = new StringBuffer();
        Token name = null;
        name = id();
        buffer.append(name.image);
        label_19:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case DOT:
                case 126:
                    ;
                    break;
                default:
                    jj_la1[101] = jj_gen;
                    break label_19;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case DOT:
                    jj_consume_token(DOT);
                    buffer.append(".");
                    break;
                case 126:
                    jj_consume_token(126);
                    buffer.append("$");
                    break;
                default:
                    jj_la1[102] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            name = id();
            buffer.append(name.image);
        }
        String classname = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? buffer.toString() : buffer.toString().toUpperCase();
        {
            if (true) return classname;
        }
        throw new Error("Missing return statement in function");
    }

    final public String sqlType() throws ParseException {
        Token param, param2 = null;
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case VARCHAR:
                case VARCHAR2:
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case VARCHAR:
                            jj_consume_token(VARCHAR);
                            break;
                        case VARCHAR2:
                            jj_consume_token(VARCHAR2);
                            break;
                        default:
                            jj_la1[103] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case OPENPAREN:
                            jj_consume_token(OPENPAREN);
                            jj_consume_token(INTEGER_LITERAL);
                            jj_consume_token(CLOSEPAREN);
                            break;
                        default:
                            jj_la1[104] = jj_gen;
                            ;
                    }
                {
                    if (true) return String.class.getName();
                }
                break;
                case CHAR:
                    jj_consume_token(CHAR);
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case OPENPAREN:
                            jj_consume_token(OPENPAREN);
                            jj_consume_token(INTEGER_LITERAL);
                            jj_consume_token(CLOSEPAREN);
                            break;
                        default:
                            jj_la1[105] = jj_gen;
                            ;
                    }
                {
                    if (true) return String.class.getName();
                }
                break;
                case DATE:
                    jj_consume_token(DATE);
                {
                    if (true) return Date.class.getName();
                }
                break;
                case DATETIME:
                    jj_consume_token(DATETIME);
                {
                    if (true) return Timestamp.class.getName();
                }
                break;
                case NUMBER:
                    jj_consume_token(NUMBER);
                    jj_consume_token(OPENPAREN);
                    param = jj_consume_token(INTEGER_LITERAL);
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case 125:
                            jj_consume_token(125);
                            param2 = jj_consume_token(INTEGER_LITERAL);
                            break;
                        default:
                            jj_la1[106] = jj_gen;
                            ;
                    }
                    jj_consume_token(CLOSEPAREN);
                    if (param2 != null && !param2.image.equals("0")) {
                        if (true) return Double.class.getName();
                    }
                    int p = Integer.parseInt(param.image);
                    if (p < 10) {
                        if (true) return Integer.class.getName();
                    } else {
                        if (true) return Long.class.getName();
                    }
                    break;
                case TIME:
                    jj_consume_token(TIME);
                {
                    if (true) return Time.class.getName();
                }
                break;
                case FLOAT:
                    jj_consume_token(FLOAT);
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case OPENPAREN:
                            jj_consume_token(OPENPAREN);
                            jj_consume_token(INTEGER_LITERAL);
                            jj_consume_token(CLOSEPAREN);
                            break;
                        default:
                            jj_la1[107] = jj_gen;
                            ;
                    }
                {
                    if (true) return Float.class.getName();
                }
                break;
                case REAL:
                    jj_consume_token(REAL);
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case OPENPAREN:
                            jj_consume_token(OPENPAREN);
                            jj_consume_token(INTEGER_LITERAL);
                            jj_consume_token(CLOSEPAREN);
                            break;
                        default:
                            jj_la1[108] = jj_gen;
                            ;
                    }
                {
                    if (true) return Float.class.getName();
                }
                break;
                case DOUBLE:
                    jj_consume_token(DOUBLE);
                {
                    if (true) return Double.class.getName();
                }
                break;
                case BOOLEAN:
                    jj_consume_token(BOOLEAN);
                {
                    if (true) return Boolean.class.getName();
                }
                break;
                case INTEGER:
                case INT:
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case INTEGER:
                            jj_consume_token(INTEGER);
                            break;
                        case INT:
                            jj_consume_token(INT);
                            break;
                        default:
                            jj_la1[109] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                {
                    if (true) return Integer.class.getName();
                }
                break;
                case LONG:
                    jj_consume_token(LONG);
                {
                    if (true) return Long.class.getName();
                }
                break;
                case BLOB:
                    jj_consume_token(BLOB);
                {
                    if (true) return Blob.class.getName();
                }
                break;
                case CLOB:
                    jj_consume_token(CLOB);
                {
                    if (true) return Clob.class.getName();
                }
                break;
                case TIMESTAMP:
                    jj_consume_token(TIMESTAMP);
                {
                    if (true) return Timestamp.class.getName();
                }
                break;
                case DECIMAL:
                    jj_consume_token(DECIMAL);
                {
                    if (true) return BigDecimal.class.getName();
                }
                break;
                case NUMERIC:
                    jj_consume_token(NUMERIC);
                {
                    if (true) return BigDecimal.class.getName();
                }
                break;
                case LONGVARCHAR:
                    jj_consume_token(LONGVARCHAR);
                {
                    if (true) return String.class.getName();
                }
                break;
                case TINYINT:
                    jj_consume_token(TINYINT);
                {
                    if (true) return Byte.class.getName();
                }
                break;
                case SMALLINT:
                    jj_consume_token(SMALLINT);
                {
                    if (true) return Short.class.getName();
                }
                break;
                case BIGINT:
                    jj_consume_token(BIGINT);
                {
                    if (true) return Long.class.getName();
                }
                break;
                case BIT:
                    jj_consume_token(BIT);
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case OPENPAREN:
                            jj_consume_token(OPENPAREN);
                            jj_consume_token(INTEGER_LITERAL);
                            jj_consume_token(CLOSEPAREN);
                            break;
                        default:
                            jj_la1[110] = jj_gen;
                            ;
                    }
                {
                    if (true) return String.class.getName();
                }
                break;
                default:
                    jj_la1[111] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } catch (ParseException p) {
            {
                if (true) throw new ParseException("unknown sql data type");
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public Token id() throws ParseException {
        Token id = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                id = jj_consume_token(IDENTIFIER);
            {
                if (true) return id;
            }
            break;
            case ESC_IDENTIFIER:
                id = jj_consume_token(ESC_IDENTIFIER);
                String idStr = id.image.substring(1, id.image.length() - 1);
                id.image = idStr;
            {
                if (true) return id;
            }
            break;
            default:
                jj_la1[112] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    //handle one condition, and add it to the Query object
    final public ExpNode condition(AbstractDMLQuery query) throws ParseException {
        Token t, table1 = null, table2 = null, addup = null, operator = null;
        ColumnNode columnNode1 = null, columnNode2 = null;

        ValueNode valueNode = null;
        String negative = "";
        ExpNode expNode = null;
        Query innerQuery = null;
        RowNumNode rowNum;
        Token startIndex, endIndex;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ROWNUM:
                jj_consume_token(ROWNUM);
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case EQUAL:
                        jj_consume_token(EQUAL);
                        t = jj_consume_token(INTEGER_LITERAL);
                        int temp = Integer.parseInt(t.image);
                        rowNum = new RowNumNode(temp, temp);
                        break;
                    case LESS:
                        jj_consume_token(LESS);
                        t = jj_consume_token(INTEGER_LITERAL);
                        temp = Integer.parseInt(t.image);
                        rowNum = new RowNumNode(1, temp - 1);
                        break;
                    case LESSEQUAL:
                        jj_consume_token(LESSEQUAL);
                        t = jj_consume_token(INTEGER_LITERAL);
                        temp = Integer.parseInt(t.image);
                        rowNum = new RowNumNode(1, temp);
                        break;
                    case GREATER:
                        jj_consume_token(GREATER);
                        t = jj_consume_token(INTEGER_LITERAL);
                        temp = Integer.parseInt(t.image);
                        rowNum = new RowNumNode(temp + 1, Integer.MAX_VALUE);
                        break;
                    case GREATEREQUAL:
                        jj_consume_token(GREATEREQUAL);
                        t = jj_consume_token(INTEGER_LITERAL);
                        temp = Integer.parseInt(t.image);
                        rowNum = new RowNumNode(temp, Integer.MAX_VALUE);
                        break;
                    case OPENPAREN:
                        jj_consume_token(OPENPAREN);
                        startIndex = jj_consume_token(INTEGER_LITERAL);
                        jj_consume_token(125);
                        endIndex = jj_consume_token(INTEGER_LITERAL);
                        jj_consume_token(CLOSEPAREN);
                        rowNum = new RowNumNode(Integer.parseInt(startIndex.image), Integer.parseInt(endIndex.image));
                        break;
                    default:
                        jj_la1[113] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                if (query.getRownum() != null) {
                    if (true)
                        throw new ParseException("Can't define more than a single condition for rownum. To specify range use rownum(from,to)");
                }
                query.setRownum(rowNum);
            {
                if (true) return null;
            }
            break;
            case IDENTIFIER:
            case ESC_IDENTIFIER:
                columnNode1 = createColumnNode(query, null);

                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COLLECTION_CONTAINS:
                        expNode = containsNode(query, columnNode1);
                        break;
                    case IS:
                        expNode = isNullNode(query, columnNode1);
                        break;
                    case BETWEEN:
                        expNode = betweenNode(query, columnNode1);
                        break;
                    case IN:
                    case LIKE:
                    case RLIKE:
                    case NOT:
                    case LESS:
                    case LESSEQUAL:
                    case GREATER:
                    case GREATEREQUAL:
                    case EQUAL:
                    case NOTEQUAL:
                    case NOTEQUAL2:
                        expNode = conditionNode(query, columnNode1);
                        break;
                    case RELATION:
                        expNode = relationNode(query, columnNode1);
                        break;
                    default:
                        jj_la1[114] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            {
                if (true) return expNode;
            }
            break;
            default:
                jj_la1[115] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode relationNode(AbstractDMLQuery query, ColumnNode columnNode) throws ParseException {
        ValueNode valueNode = null;
        ExpNode res = null;
        Token rel = null;
        Token t;
        rel = jj_consume_token(RELATION);
        t = jj_consume_token(QUESTIONMARK);
        query.setPrepared(true);
        valueNode = new PreparedNode(null, ++conditionIndex);
        res = new RelationNode(columnNode, rel.image, valueNode);
        {
            if (true) return res;
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode conditionNode(AbstractDMLQuery query, ColumnNode columnNode1) throws ParseException {
        Token t, addup = null, operator = null;
        ValueNode valueNode = null;
        ExpNode expNode = null;
        String negative = "";
        Query innerQuery = null;
        ColumnNode columnNode2 = null;
        if (jj_2_18(2)) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case EQUAL:
                    jj_consume_token(EQUAL);
                    expNode = new EqualNode();
                    break;
                case LESS:
                    jj_consume_token(LESS);
                    expNode = new LTNode();
                    break;
                case LESSEQUAL:
                    jj_consume_token(LESSEQUAL);
                    expNode = new LTENode();
                    break;
                case GREATER:
                    jj_consume_token(GREATER);
                    expNode = new GTNode();
                    break;
                case GREATEREQUAL:
                    jj_consume_token(GREATEREQUAL);
                    expNode = new GTENode();
                    break;
                case NOTEQUAL:
                    jj_consume_token(NOTEQUAL);
                    expNode = new NotEqualNode();
                    break;
                case NOTEQUAL2:
                    jj_consume_token(NOTEQUAL2);
                    expNode = new NotEqualNode();
                    break;
                case LIKE:
                    jj_consume_token(LIKE);
                    expNode = new LikeNode();
                    break;
                case NOT:
                    jj_consume_token(NOT);
                    jj_consume_token(LIKE);
                    expNode = new NotLikeNode();
                    break;
                case RLIKE:
                    jj_consume_token(RLIKE);
                    expNode = new RLikeNode();
                    break;
                default:
                    jj_la1[116] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case QUESTIONMARK:
                    t = jj_consume_token(QUESTIONMARK);
                    query.setPrepared(true);
                    valueNode = new PreparedNode(null, ++conditionIndex);
                    break;
                case STRING_LITERAL:
                    t = jj_consume_token(STRING_LITERAL);
                    valueNode = new LiteralNode(new String(t.image.substring(1, t.image.length() - 1)));
                    break;
                case TRUE:
                    t = jj_consume_token(TRUE);
                    valueNode = new LiteralNode(Boolean.TRUE);
                    break;
                case FALSE:
                    t = jj_consume_token(FALSE);
                    valueNode = new LiteralNode(Boolean.FALSE);
                    break;
                default:
                    jj_la1[122] = jj_gen;
                    if (jj_2_15(2)) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case MINUS:
                                jj_consume_token(MINUS);
                                negative = "-";
                                break;
                            default:
                                jj_la1[117] = jj_gen;
                                ;
                        }
                        t = jj_consume_token(INTEGER_LITERAL);
                        valueNode = new LiteralNode(negative + t.image);
                    } else if (jj_2_16(2)) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case MINUS:
                                jj_consume_token(MINUS);
                                negative = "-";
                                break;
                            default:
                                jj_la1[118] = jj_gen;
                                ;
                        }
                        t = jj_consume_token(LONG_LITERAL);
                        valueNode = new LiteralNode(negative + t.image.substring(0, t.image.length() - 1));
                    } else if (jj_2_17(2)) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case MINUS:
                                jj_consume_token(MINUS);
                                negative = "-";
                                break;
                            default:
                                jj_la1[119] = jj_gen;
                                ;
                        }
                        t = jj_consume_token(FLOATING_POINT_LITERAL);
                        valueNode = new LiteralNode(negative + t.image);
                    } else {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case DATE_LITERAL:
                                t = jj_consume_token(DATE_LITERAL);
                                valueNode = new LiteralNode(t.image);
                                break;
                            case SYSDATE:
                                jj_consume_token(SYSDATE);
                                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                    case PLUS:
                                    case MINUS:
                                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                            case PLUS:
                                                operator = jj_consume_token(PLUS);
                                                break;
                                            case MINUS:
                                                operator = jj_consume_token(MINUS);
                                                break;
                                            default:
                                                jj_la1[120] = jj_gen;
                                                jj_consume_token(-1);
                                                throw new ParseException();
                                        }
                                        addup = jj_consume_token(INTEGER_LITERAL);
                                        break;
                                    default:
                                        jj_la1[121] = jj_gen;
                                        ;
                                }
                                Calendar cal = Calendar.getInstance();
                                if (addup != null) {
                                    if (operator.image.equals("+"))
                                        cal.add(Calendar.DATE, Integer.parseInt(addup.image));
                                    else if (operator.image.equals("-"))
                                        cal.add(Calendar.DATE, -(Integer.parseInt(addup.image)));
                                }
                                valueNode = new LiteralNode(new java.sql.Timestamp(cal.getTime().getTime()));
                                break;
                            case OPENPAREN:
                                jj_consume_token(OPENPAREN);
                                innerQuery = selectSql();
                                valueNode = new InnerQueryNode((SelectQuery) innerQuery);
                                query.setContainsSubQueries(true);
                                jj_consume_token(CLOSEPAREN);
                                break;
                            case IDENTIFIER:
                            case ESC_IDENTIFIER:
                                columnNode2 = createColumnNode(query, null);

                                break;
                            default:
                                jj_la1[123] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                    }
            }
        } else if (jj_2_19(2)) {
            expNode = SqlInClause(query);
            expNode.setLeftChild(columnNode1);
            {
                if (true) return expNode;
            }
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        expNode.setLeftChild(columnNode1);
        if (columnNode2 == null)
            expNode.setRightChild(valueNode);
        else {
            expNode.setRightChild(columnNode2);
        }
        {
            if (true) return expNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode isNullNode(AbstractDMLQuery query, ColumnNode columnNode1) throws ParseException {
        IsNullNode expNode = null;
        if (jj_2_20(2)) {
            jj_consume_token(IS);
            jj_consume_token(NULL);
            expNode = new IsNullNode(columnNode1, new LiteralNode(null));
        } else if (jj_2_21(2)) {
            jj_consume_token(IS);
            jj_consume_token(NOT);
            jj_consume_token(NULL);
            expNode = new IsNullNode(columnNode1, new LiteralNode(null));
            expNode.setNot(true);
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true) return expNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public AndNode betweenNode(AbstractDMLQuery query, ColumnNode columnNode1) throws ParseException {
        ValueNode valueNode = null;
        ExpNode expNode = null;
        jj_consume_token(BETWEEN);
        ExpNode gteNode = new GTENode(columnNode1, null);
        ExpNode lteNode = new LTENode(columnNode1, null);
        valueNode = getBetweenValueNode(query);
        gteNode.setRightChild(valueNode);
        jj_consume_token(AND);
        valueNode = getBetweenValueNode(query);
        lteNode.setRightChild(valueNode);
        {
            if (true) return new AndNode(gteNode, lteNode);
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode containsSimpleItemNode(AbstractDMLQuery query, ColumnNode columnNode1, StringBuilder columnPath, boolean insideInternalContains) throws ParseException {
        Token t, table1 = null, table2 = null, addup = null, operator = null;
        ColumnNode columnNode2 = null;

        ValueNode valueNode = null;
        String negative = "";
        ExpNode expNode = null;
        Token startIndex, endIndex;
        short templateMatchCode = TemplateMatchCodes.EQ;
        ContainsItemNode containsItems = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case EQUAL:
                jj_consume_token(EQUAL);
                templateMatchCode = TemplateMatchCodes.EQ;
                break;
            case LESS:
                jj_consume_token(LESS);
                templateMatchCode = TemplateMatchCodes.LT;
                break;
            case LESSEQUAL:
                jj_consume_token(LESSEQUAL);
                templateMatchCode = TemplateMatchCodes.LE;
                break;
            case GREATER:
                jj_consume_token(GREATER);
                templateMatchCode = TemplateMatchCodes.GT;
                break;
            case GREATEREQUAL:
                jj_consume_token(GREATEREQUAL);
                templateMatchCode = TemplateMatchCodes.GE;
                break;
            case NOTEQUAL:
                jj_consume_token(NOTEQUAL);
                templateMatchCode = TemplateMatchCodes.NE;
                break;
            case NOTEQUAL2:
                jj_consume_token(NOTEQUAL2);
                templateMatchCode = TemplateMatchCodes.NE;
                break;
            case LIKE:
                jj_consume_token(LIKE);
                templateMatchCode = TemplateMatchCodes.REGEX;
                break;
            case NOT:
                jj_consume_token(NOT);
                jj_consume_token(LIKE);
                templateMatchCode = TemplateMatchCodes.NOT_REGEX;
                break;
            case OPENPAREN:
                jj_consume_token(OPENPAREN);
                columnNode1.setName(columnPath.toString());
                valueNode = new ContainsItemsRootNode(SqlContainsItemExpression(query), columnPath.toString(), columnNode1);
                jj_consume_token(CLOSEPAREN);
                if (insideInternalContains) {
                    if (true)
                        return new ContainsItemNode(columnNode1, valueNode, templateMatchCode);
                }

            {
                if (true) throw new ParseException("invalid token inside contains conditions");
            }
            break;
            default:
                jj_la1[124] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case QUESTIONMARK:
                t = jj_consume_token(QUESTIONMARK);
                query.setPrepared(true);
                valueNode = new PreparedNode(null, ++conditionIndex);
                break;
            case STRING_LITERAL:
                t = jj_consume_token(STRING_LITERAL);
                valueNode = new LiteralNode(new String(t.image.substring(1, t.image.length() - 1)));
                break;
            case TRUE:
                t = jj_consume_token(TRUE);
                valueNode = new LiteralNode(Boolean.TRUE);
                break;
            case FALSE:
                t = jj_consume_token(FALSE);
                valueNode = new LiteralNode(Boolean.FALSE);
                break;
            default:
                jj_la1[128] = jj_gen;
                if (jj_2_22(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[125] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(INTEGER_LITERAL);
                    valueNode = new LiteralNode(new Integer(negative + t.image));
                } else if (jj_2_23(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[126] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(LONG_LITERAL);
                    valueNode = new LiteralNode(negative + t.image.substring(0, t.image.length() - 1));
                } else if (jj_2_24(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[127] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(FLOATING_POINT_LITERAL);
                    valueNode = new LiteralNode(negative + t.image);
                } else {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case DATE_LITERAL:
                            t = jj_consume_token(DATE_LITERAL);
                            valueNode = new LiteralNode(t.image);
                            break;
                        default:
                            jj_la1[129] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                }
        }
        if (columnPath != null)
            columnNode1.setName(columnPath.toString());
        {
            if (true) return new ContainsItemNode(columnNode1, valueNode, templateMatchCode);
        }
        throw new Error("Missing return statement in function");
    }

    final public AndNode containsBetweenItemNode(AbstractDMLQuery query, ColumnNode columnNode1, StringBuilder columnPath) throws ParseException {
        ValueNode gteValue, lteValue;
        jj_consume_token(BETWEEN);
        gteValue = getBetweenValueNode(query);
        jj_consume_token(AND);
        lteValue = getBetweenValueNode(query);
        if (columnPath != null)
            columnNode1.setName(columnPath.toString());
        ExpNode gteNode = new ContainsItemNode(columnNode1, gteValue, TemplateMatchCodes.GE);
        ExpNode lteNode = new ContainsItemNode(columnNode1, lteValue, TemplateMatchCodes.LE);

        {
            if (true) return new AndNode(gteNode, lteNode);
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode containsInItemNode(AbstractDMLQuery query, ColumnNode columnNode1, StringBuilder columnPath) throws ParseException {
        ExpNode inNode;
        boolean notIn = false;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NOT:
                jj_consume_token(NOT);
                notIn = true;
                break;
            default:
                jj_la1[130] = jj_gen;
                ;
        }
        jj_consume_token(IN);
        jj_consume_token(OPENPAREN);
        inNode = inExprOrList(query, notIn);
        jj_consume_token(CLOSEPAREN);
        if (columnPath != null)
            columnNode1.setName(columnPath.toString());
        inNode.setLeftChild(columnNode1);

        {
            if (true) return new ContainsItemNode(columnNode1, inNode, TemplateMatchCodes.IN);
        }
        throw new Error("Missing return statement in function");
    }

    final public AndNode containsBetweenNode(AbstractDMLQuery query, ColumnNode columnNode1, String column) throws ParseException {
        ValueNode gteValue, lteValue;
        jj_consume_token(BETWEEN);
        gteValue = getBetweenValueNode(query);
        jj_consume_token(AND);
        lteValue = getBetweenValueNode(query);
        columnNode1.setName(column);
        ExpNode gteNode = new ContainsNode(columnNode1, gteValue, TemplateMatchCodes.GE);
        ExpNode lteNode = new ContainsNode(columnNode1, lteValue, TemplateMatchCodes.LE);

        {
            if (true) return new AndNode(gteNode, lteNode);
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode containsSimpleNode(AbstractDMLQuery query, ColumnNode columnNode1, String column) throws ParseException {
        ValueNode valueNode = null;
        short templateMatchCode;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case EQUAL:
                jj_consume_token(EQUAL);
                templateMatchCode = TemplateMatchCodes.EQ;
                break;
            case LESS:
                jj_consume_token(LESS);
                templateMatchCode = TemplateMatchCodes.LT;
                break;
            case LESSEQUAL:
                jj_consume_token(LESSEQUAL);
                templateMatchCode = TemplateMatchCodes.LE;
                break;
            case GREATER:
                jj_consume_token(GREATER);
                templateMatchCode = TemplateMatchCodes.GT;
                break;
            case GREATEREQUAL:
                jj_consume_token(GREATEREQUAL);
                templateMatchCode = TemplateMatchCodes.GE;
                break;
            case NOTEQUAL:
                jj_consume_token(NOTEQUAL);
                templateMatchCode = TemplateMatchCodes.NE;
                break;
            case NOTEQUAL2:
                jj_consume_token(NOTEQUAL2);
                templateMatchCode = TemplateMatchCodes.NE;
                break;
            case LIKE:
                jj_consume_token(LIKE);
                templateMatchCode = TemplateMatchCodes.REGEX;
                break;
            case NOT:
                jj_consume_token(NOT);
                jj_consume_token(LIKE);
                templateMatchCode = TemplateMatchCodes.NOT_REGEX;
                break;
            default:
                jj_la1[131] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        valueNode = valueNode(query);
        columnNode1.setName(column);
        {
            if (true) return new ContainsNode(columnNode1, valueNode, templateMatchCode);
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode containsInNode(AbstractDMLQuery query, ColumnNode columnNode1, String column) throws ParseException {
        ExpNode inNode;
        boolean notIn = false;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NOT:
                jj_consume_token(NOT);
                notIn = true;
                break;
            default:
                jj_la1[132] = jj_gen;
                ;
        }
        jj_consume_token(IN);
        jj_consume_token(OPENPAREN);
        inNode = inExprOrList(query, notIn);
        jj_consume_token(CLOSEPAREN);
        columnNode1.setName(column);
        inNode.setLeftChild(columnNode1);

        {
            if (true) return new ContainsNode(columnNode1, inNode, TemplateMatchCodes.IN);
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode containsNode(AbstractDMLQuery query, ColumnNode columnNode1) throws ParseException {
        Token t;
        ValueNode valueNode = null;
        String negative = "";
        ExpNode expNode = null;
        ContainsItemNode containsItems = null;
        jj_consume_token(COLLECTION_CONTAINS);
        query.setContainsQuery(true);
        StringBuilder columnPath = new StringBuilder(columnNode1.toString());
        columnPath.append("[*]");
        short templateMatchCode = TemplateMatchCodes.EQ;
        label_20:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COLLECTION_CONTAINS:
                    ;
                    break;
                default:
                    jj_la1[133] = jj_gen;
                    break label_20;
            }
            jj_consume_token(COLLECTION_CONTAINS);
            columnPath.append("[*]");
        }
        label_21:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case DOT:
                    ;
                    break;
                default:
                    jj_la1[134] = jj_gen;
                    break label_21;
            }
            jj_consume_token(DOT);
            t = id();
            String columnNameSuffix = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? t.image : t.image.toUpperCase();
            columnPath.append(".");
            columnPath.append(columnNameSuffix);
            label_22:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COLLECTION_CONTAINS:
                        ;
                        break;
                    default:
                        jj_la1[135] = jj_gen;
                        break label_22;
                }
                jj_consume_token(COLLECTION_CONTAINS);
                columnPath.append("[*]");
            }
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case BETWEEN:
            case IN:
            case LIKE:
            case NOT:
            case LESS:
            case LESSEQUAL:
            case GREATER:
            case GREATEREQUAL:
            case EQUAL:
            case NOTEQUAL:
            case NOTEQUAL2:
                expNode = containsSingleNode(query, columnNode1, columnPath.toString());
                break;
            case OPENPAREN:
                expNode = containsMultipleNode(query, columnNode1, columnPath.toString());
                break;
            default:
                jj_la1[136] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return expNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode containsMultipleNode(AbstractDMLQuery query, ColumnNode columnNode1, String columnPath) throws ParseException {
        ValueNode valueNode = null;
        jj_consume_token(OPENPAREN);
        columnNode1.setName(columnPath);
        valueNode = new ContainsItemsRootNode(SqlContainsItemExpression(query), columnPath, columnNode1);
        jj_consume_token(CLOSEPAREN);
        {
            if (true) return new ContainsItemNode(columnNode1, valueNode, TemplateMatchCodes.EQ);
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode containsSingleNode(AbstractDMLQuery query, ColumnNode columnNode1, String column) throws ParseException {
        ExpNode expNode = null;
        if (jj_2_25(2)) {
            expNode = containsInNode(query, columnNode1, column);
        } else if (jj_2_26(2)) {
            expNode = containsBetweenNode(query, columnNode1, column);
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LIKE:
                case NOT:
                case LESS:
                case LESSEQUAL:
                case GREATER:
                case GREATEREQUAL:
                case EQUAL:
                case NOTEQUAL:
                case NOTEQUAL2:
                    expNode = containsSimpleNode(query, columnNode1, column);
                    break;
                default:
                    jj_la1[137] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        {
            if (true) return expNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode valueNode(AbstractDMLQuery query) throws ParseException {
        Token t;
        ValueNode valueNode = null;
        String negative = "";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case QUESTIONMARK:
                t = jj_consume_token(QUESTIONMARK);
                query.setPrepared(true);
                valueNode = new PreparedNode(null, ++conditionIndex);
                break;
            case STRING_LITERAL:
                t = jj_consume_token(STRING_LITERAL);
                valueNode = new LiteralNode(new String(t.image.substring(1, t.image.length() - 1)));
                break;
            case TRUE:
                t = jj_consume_token(TRUE);
                valueNode = new LiteralNode(Boolean.TRUE);
                break;
            case FALSE:
                t = jj_consume_token(FALSE);
                valueNode = new LiteralNode(Boolean.FALSE);
                break;
            default:
                jj_la1[141] = jj_gen;
                if (jj_2_27(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[138] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(INTEGER_LITERAL);
                    valueNode = new LiteralNode(new Integer(negative + t.image));
                } else if (jj_2_28(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[139] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(LONG_LITERAL);
                    valueNode = new LiteralNode(negative + t.image.substring(0, t.image.length() - 1));
                } else if (jj_2_29(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[140] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(FLOATING_POINT_LITERAL);
                    valueNode = new LiteralNode(negative + t.image);
                } else {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case DATE_LITERAL:
                            t = jj_consume_token(DATE_LITERAL);
                            valueNode = new LiteralNode(t.image);
                            break;
                        default:
                            jj_la1[142] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                }
        }
        {
            if (true) return valueNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpNode inExprOrList(AbstractDMLQuery query, boolean isNot) throws ParseException {
        Query innerQuery = null;
        ExpNode expNode = null;
        HashSet<LiteralNode> valuelist;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SELECT:
                innerQuery = selectSql();
                if (isNot) {
                    expNode = new NotInNode();
                } else {
                    expNode = new InNode();
                }
                query.setContainsSubQueries(true);
                expNode.setRightChild(new InnerQueryNode((SelectQuery) innerQuery));
            {
                if (true) return expNode;
            }
            break;
            case NULL:
            case EMPTY_CLOB:
            case EMPTY_BLOB:
            case TRUE:
            case FALSE:
            case INTEGER_LITERAL:
            case LONG_LITERAL:
            case FLOATING_POINT_LITERAL:
            case STRING_LITERAL:
            case MINUS:
            case QUESTIONMARK:
                valuelist = inValueList(query);
                if (isNot) {
                    expNode = new NotInNode();
                    ((NotInNode) expNode).setValuesList(valuelist);
                } else {
                    expNode = new InNode();
                    ((InNode) expNode).setValuesList(valuelist);
                }
            {
                if (true) return expNode;
            }
            break;
            default:
                jj_la1[143] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public LiteralNode parseInValue(AbstractDMLQuery query) throws ParseException {
        Token t = null;
        LiteralNode value = null;
        String negative = "";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case TRUE:
                t = jj_consume_token(TRUE);
                value = new LiteralNode(Boolean.TRUE);
                break;
            case FALSE:
                jj_consume_token(FALSE);
                value = new LiteralNode(Boolean.FALSE);
                break;
            case NULL:
                jj_consume_token(NULL);
                value = new LiteralNode(null);
                break;
            case EMPTY_CLOB:
                jj_consume_token(EMPTY_CLOB);
                value = new LiteralNode(new Clob(""));
                break;
            case EMPTY_BLOB:
                jj_consume_token(EMPTY_BLOB);
                value = new LiteralNode(new Blob(new byte[0]));
                break;
            case QUESTIONMARK:
                jj_consume_token(QUESTIONMARK);
                query.setPrepared(true);
                value = new PreparedNode(null, ++conditionIndex);
                break;
            case STRING_LITERAL:
                t = jj_consume_token(STRING_LITERAL);
                value = new LiteralNode(new String(t.image.substring(1, t.image.length() - 1)));
                break;
            default:
                jj_la1[147] = jj_gen;
                if (jj_2_30(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[144] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(INTEGER_LITERAL);
                    value = new LiteralNode(negative + t.image);
                } else if (jj_2_31(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[145] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(LONG_LITERAL);
                    value = new LiteralNode(negative + t.image.substring(0, t.image.length() - 1));
                } else if (jj_2_32(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[146] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(FLOATING_POINT_LITERAL);
                    value = new LiteralNode(negative + t.image);
                } else {
                    jj_consume_token(-1);
                    throw new ParseException();
                }
        }
        {
            if (true) return value;
        }
        throw new Error("Missing return statement in function");
    }

    final public HashSet<LiteralNode> inValueList(AbstractDMLQuery query) throws ParseException {
        LiteralNode value = null;
        HashSet<LiteralNode> list = new HashSet<LiteralNode>();
        value = parseInValue(query);
        list.add(value);
        label_23:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 125:
                    ;
                    break;
                default:
                    jj_la1[148] = jj_gen;
                    break label_23;
            }
            jj_consume_token(125);
            value = parseInValue(query);
            list.add(value);
        }
        {
            if (true) return list;
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode getBetweenValueNode(AbstractDMLQuery query) throws ParseException {
        ValueNode valueNode = null;
        Token t = null, operator = null, addup = null;
        String negative = "";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case QUESTIONMARK:
                t = jj_consume_token(QUESTIONMARK);
                query.setPrepared(true);
                valueNode = new PreparedNode(null, ++conditionIndex);
                break;
            case STRING_LITERAL:
                t = jj_consume_token(STRING_LITERAL);
                valueNode = new LiteralNode(new String(t.image.substring(1, t.image.length() - 1)));
                break;
            case TRUE:
                t = jj_consume_token(TRUE);
                valueNode = new LiteralNode(Boolean.TRUE);
                break;
            case FALSE:
                t = jj_consume_token(FALSE);
                valueNode = new LiteralNode(Boolean.FALSE);
                break;
            default:
                jj_la1[154] = jj_gen;
                if (jj_2_33(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[149] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(INTEGER_LITERAL);
                    valueNode = new LiteralNode(negative + t.image);
                } else if (jj_2_34(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[150] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(LONG_LITERAL);
                    valueNode = new LiteralNode(negative + t.image.substring(0, t.image.length() - 1));
                } else if (jj_2_35(2)) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MINUS:
                            jj_consume_token(MINUS);
                            negative = "-";
                            break;
                        default:
                            jj_la1[151] = jj_gen;
                            ;
                    }
                    t = jj_consume_token(FLOATING_POINT_LITERAL);
                    valueNode = new LiteralNode(negative + t.image);
                } else {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case DATE_LITERAL:
                            t = jj_consume_token(DATE_LITERAL);
                            valueNode = new LiteralNode(t.image);
                            break;
                        case SYSDATE:
                            jj_consume_token(SYSDATE);
                            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                case PLUS:
                                case MINUS:
                                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                        case PLUS:
                                            operator = jj_consume_token(PLUS);
                                            break;
                                        case MINUS:
                                            operator = jj_consume_token(MINUS);
                                            break;
                                        default:
                                            jj_la1[152] = jj_gen;
                                            jj_consume_token(-1);
                                            throw new ParseException();
                                    }
                                    addup = jj_consume_token(INTEGER_LITERAL);
                                    break;
                                default:
                                    jj_la1[153] = jj_gen;
                                    ;
                            }
                            Calendar cal = Calendar.getInstance();
                            if (addup != null) {
                                if (operator.image.equals("+"))
                                    cal.add(Calendar.DATE, Integer.parseInt(addup.image));
                                else if (operator.image.equals("-"))
                                    cal.add(Calendar.DATE, -(Integer.parseInt(addup.image)));
                            }
                            valueNode = new LiteralNode(new java.sql.Timestamp(cal.getTime().getTime()));
                            break;
                        default:
                            jj_la1[155] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                }
        }
        {
            if (true) return valueNode;
        }
        throw new Error("Missing return statement in function");
    }

    private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_1();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(0, xla);
        }
    }

    private boolean jj_2_2(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_2();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(1, xla);
        }
    }

    private boolean jj_2_3(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_3();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(2, xla);
        }
    }

    private boolean jj_2_4(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_4();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(3, xla);
        }
    }

    private boolean jj_2_5(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_5();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(4, xla);
        }
    }

    private boolean jj_2_6(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_6();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(5, xla);
        }
    }

    private boolean jj_2_7(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_7();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(6, xla);
        }
    }

    private boolean jj_2_8(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_8();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(7, xla);
        }
    }

    private boolean jj_2_9(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_9();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(8, xla);
        }
    }

    private boolean jj_2_10(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_10();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(9, xla);
        }
    }

    private boolean jj_2_11(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_11();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(10, xla);
        }
    }

    private boolean jj_2_12(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_12();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(11, xla);
        }
    }

    private boolean jj_2_13(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_13();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(12, xla);
        }
    }

    private boolean jj_2_14(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_14();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(13, xla);
        }
    }

    private boolean jj_2_15(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_15();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(14, xla);
        }
    }

    private boolean jj_2_16(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_16();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(15, xla);
        }
    }

    private boolean jj_2_17(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_17();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(16, xla);
        }
    }

    private boolean jj_2_18(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_18();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(17, xla);
        }
    }

    private boolean jj_2_19(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_19();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(18, xla);
        }
    }

    private boolean jj_2_20(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_20();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(19, xla);
        }
    }

    private boolean jj_2_21(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_21();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(20, xla);
        }
    }

    private boolean jj_2_22(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_22();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(21, xla);
        }
    }

    private boolean jj_2_23(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_23();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(22, xla);
        }
    }

    private boolean jj_2_24(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_24();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(23, xla);
        }
    }

    private boolean jj_2_25(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_25();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(24, xla);
        }
    }

    private boolean jj_2_26(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_26();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(25, xla);
        }
    }

    private boolean jj_2_27(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_27();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(26, xla);
        }
    }

    private boolean jj_2_28(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_28();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(27, xla);
        }
    }

    private boolean jj_2_29(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_29();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(28, xla);
        }
    }

    private boolean jj_2_30(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_30();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(29, xla);
        }
    }

    private boolean jj_2_31(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_31();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(30, xla);
        }
    }

    private boolean jj_2_32(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_32();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(31, xla);
        }
    }

    private boolean jj_2_33(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_33();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(32, xla);
        }
    }

    private boolean jj_2_34(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_34();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(33, xla);
        }
    }

    private boolean jj_2_35(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_35();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(34, xla);
        }
    }

    private boolean jj_3R_24() {
        if (jj_3R_25()) return true;
        return false;
    }

    private boolean jj_3R_89() {
        if (jj_3R_25()) return true;
        return false;
    }

    private boolean jj_3_21() {
        if (jj_scan_token(IS)) return true;
        if (jj_scan_token(NOT)) return true;
        return false;
    }

    private boolean jj_3_20() {
        if (jj_scan_token(IS)) return true;
        if (jj_scan_token(NULL)) return true;
        return false;
    }

    private boolean jj_3R_55() {
        if (jj_3R_80()) return true;
        return false;
    }

    private boolean jj_3R_70() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_69() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_80() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_6()) {
            jj_scanpos = xsp;
            if (jj_3R_89()) return true;
        }
        return false;
    }

    private boolean jj_3R_68() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3_6() {
        if (jj_scan_token(IDENTIFIER)) return true;
        if (jj_scan_token(OPENPAREN)) return true;
        return false;
    }

    private boolean jj_3_19() {
        if (jj_3R_56()) return true;
        return false;
    }

    private boolean jj_3R_37() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_54() {
        if (jj_scan_token(OPENPAREN)) return true;
        return false;
    }

    private boolean jj_3R_36() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_35() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_88() {
        if (jj_scan_token(SYSDATE)) return true;
        return false;
    }

    private boolean jj_3R_82() {
        if (jj_scan_token(NOT)) return true;
        return false;
    }

    private boolean jj_3R_87() {
        if (jj_scan_token(DATE_LITERAL)) return true;
        return false;
    }

    private boolean jj_3R_81() {
        if (jj_scan_token(NOT)) return true;
        return false;
    }

    private boolean jj_3R_60() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_82()) jj_scanpos = xsp;
        if (jj_scan_token(IN)) return true;
        if (jj_scan_token(OPENPAREN)) return true;
        return false;
    }

    private boolean jj_3R_53() {
        if (jj_scan_token(SYSDATE)) return true;
        return false;
    }

    private boolean jj_3_35() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_70()) jj_scanpos = xsp;
        if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
        return false;
    }

    private boolean jj_3R_56() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_81()) jj_scanpos = xsp;
        if (jj_scan_token(IN)) return true;
        if (jj_scan_token(OPENPAREN)) return true;
        return false;
    }

    private boolean jj_3R_52() {
        if (jj_scan_token(DATE_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_34() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_69()) jj_scanpos = xsp;
        if (jj_scan_token(LONG_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_17() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_37()) jj_scanpos = xsp;
        if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_33() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_68()) jj_scanpos = xsp;
        if (jj_scan_token(INTEGER_LITERAL)) return true;
        return false;
    }

    private boolean jj_3R_86() {
        if (jj_scan_token(FALSE)) return true;
        return false;
    }

    private boolean jj_3_16() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_36()) jj_scanpos = xsp;
        if (jj_scan_token(LONG_LITERAL)) return true;
        return false;
    }

    private boolean jj_3R_85() {
        if (jj_scan_token(TRUE)) return true;
        return false;
    }

    private boolean jj_3R_83() {
        if (jj_scan_token(QUESTIONMARK)) return true;
        return false;
    }

    private boolean jj_3_15() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_35()) jj_scanpos = xsp;
        if (jj_scan_token(INTEGER_LITERAL)) return true;
        return false;
    }

    private boolean jj_3R_84() {
        if (jj_scan_token(STRING_LITERAL)) return true;
        return false;
    }

    private boolean jj_3R_51() {
        if (jj_scan_token(FALSE)) return true;
        return false;
    }

    private boolean jj_3R_50() {
        if (jj_scan_token(TRUE)) return true;
        return false;
    }

    private boolean jj_3R_49() {
        if (jj_scan_token(STRING_LITERAL)) return true;
        return false;
    }

    private boolean jj_3R_48() {
        if (jj_scan_token(QUESTIONMARK)) return true;
        return false;
    }

    private boolean jj_3R_47() {
        if (jj_scan_token(RLIKE)) return true;
        return false;
    }

    private boolean jj_3R_79() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_83()) {
            jj_scanpos = xsp;
            if (jj_3R_84()) {
                jj_scanpos = xsp;
                if (jj_3R_85()) {
                    jj_scanpos = xsp;
                    if (jj_3R_86()) {
                        jj_scanpos = xsp;
                        if (jj_3_33()) {
                            jj_scanpos = xsp;
                            if (jj_3_34()) {
                                jj_scanpos = xsp;
                                if (jj_3_35()) {
                                    jj_scanpos = xsp;
                                    if (jj_3R_87()) {
                                        jj_scanpos = xsp;
                                        if (jj_3R_88()) return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_46() {
        if (jj_scan_token(NOT)) return true;
        if (jj_scan_token(LIKE)) return true;
        return false;
    }

    private boolean jj_3_14() {
        if (jj_3R_34()) return true;
        return false;
    }

    private boolean jj_3R_45() {
        if (jj_scan_token(LIKE)) return true;
        return false;
    }

    private boolean jj_3_13() {
        if (jj_3R_33()) return true;
        return false;
    }

    private boolean jj_3R_44() {
        if (jj_scan_token(NOTEQUAL2)) return true;
        return false;
    }

    private boolean jj_3R_43() {
        if (jj_scan_token(NOTEQUAL)) return true;
        return false;
    }

    private boolean jj_3R_42() {
        if (jj_scan_token(GREATEREQUAL)) return true;
        return false;
    }

    private boolean jj_3R_41() {
        if (jj_scan_token(GREATER)) return true;
        return false;
    }

    private boolean jj_3R_40() {
        if (jj_scan_token(LESSEQUAL)) return true;
        return false;
    }

    private boolean jj_3R_39() {
        if (jj_scan_token(LESS)) return true;
        return false;
    }

    private boolean jj_3R_67() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_38() {
        if (jj_scan_token(EQUAL)) return true;
        return false;
    }

    private boolean jj_3R_66() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_65() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3_18() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_38()) {
            jj_scanpos = xsp;
            if (jj_3R_39()) {
                jj_scanpos = xsp;
                if (jj_3R_40()) {
                    jj_scanpos = xsp;
                    if (jj_3R_41()) {
                        jj_scanpos = xsp;
                        if (jj_3R_42()) {
                            jj_scanpos = xsp;
                            if (jj_3R_43()) {
                                jj_scanpos = xsp;
                                if (jj_3R_44()) {
                                    jj_scanpos = xsp;
                                    if (jj_3R_45()) {
                                        jj_scanpos = xsp;
                                        if (jj_3R_46()) {
                                            jj_scanpos = xsp;
                                            if (jj_3R_47()) return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        xsp = jj_scanpos;
        if (jj_3R_48()) {
            jj_scanpos = xsp;
            if (jj_3R_49()) {
                jj_scanpos = xsp;
                if (jj_3R_50()) {
                    jj_scanpos = xsp;
                    if (jj_3R_51()) {
                        jj_scanpos = xsp;
                        if (jj_3_15()) {
                            jj_scanpos = xsp;
                            if (jj_3_16()) {
                                jj_scanpos = xsp;
                                if (jj_3_17()) {
                                    jj_scanpos = xsp;
                                    if (jj_3R_52()) {
                                        jj_scanpos = xsp;
                                        if (jj_3R_53()) {
                                            jj_scanpos = xsp;
                                            if (jj_3R_54()) {
                                                jj_scanpos = xsp;
                                                if (jj_3R_55()) return true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3_32() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_67()) jj_scanpos = xsp;
        if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
        return false;
    }

    private boolean jj_3R_77() {
        if (jj_scan_token(AVG)) return true;
        return false;
    }

    private boolean jj_3_31() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_66()) jj_scanpos = xsp;
        if (jj_scan_token(LONG_LITERAL)) return true;
        return false;
    }

    private boolean jj_3R_76() {
        if (jj_scan_token(MIN)) return true;
        return false;
    }

    private boolean jj_3_30() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_65()) jj_scanpos = xsp;
        if (jj_scan_token(INTEGER_LITERAL)) return true;
        return false;
    }

    private boolean jj_3R_75() {
        if (jj_scan_token(MAX)) return true;
        return false;
    }

    private boolean jj_3R_74() {
        if (jj_scan_token(COUNT)) return true;
        return false;
    }

    private boolean jj_3R_73() {
        if (jj_scan_token(SUM)) return true;
        return false;
    }

    private boolean jj_3R_26() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_73()) {
            jj_scanpos = xsp;
            if (jj_3R_74()) {
                jj_scanpos = xsp;
                if (jj_3R_75()) {
                    jj_scanpos = xsp;
                    if (jj_3R_76()) {
                        jj_scanpos = xsp;
                        if (jj_3R_77()) return true;
                    }
                }
            }
        }
        if (jj_scan_token(OPENPAREN)) return true;
        return false;
    }

    private boolean jj_3R_61() {
        if (jj_scan_token(BETWEEN)) return true;
        if (jj_3R_79()) return true;
        return false;
    }

    private boolean jj_3R_32() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_31() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_30() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_78() {
        if (jj_scan_token(NOT)) return true;
        return false;
    }

    private boolean jj_3R_33() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_78()) jj_scanpos = xsp;
        if (jj_scan_token(IN)) return true;
        if (jj_scan_token(OPENPAREN)) return true;
        return false;
    }

    private boolean jj_3R_29() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_28() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_27() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3_12() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_32()) jj_scanpos = xsp;
        if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_11() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_31()) jj_scanpos = xsp;
        if (jj_scan_token(LONG_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_10() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_30()) jj_scanpos = xsp;
        if (jj_scan_token(INTEGER_LITERAL)) return true;
        return false;
    }

    private boolean jj_3R_59() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_58() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_64() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_57() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_63() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3R_62() {
        if (jj_scan_token(MINUS)) return true;
        return false;
    }

    private boolean jj_3_9() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_29()) jj_scanpos = xsp;
        if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_8() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_28()) jj_scanpos = xsp;
        if (jj_scan_token(LONG_LITERAL)) return true;
        return false;
    }

    private boolean jj_3R_34() {
        if (jj_scan_token(BETWEEN)) return true;
        if (jj_3R_79()) return true;
        return false;
    }

    private boolean jj_3_7() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_27()) jj_scanpos = xsp;
        if (jj_scan_token(INTEGER_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_24() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_59()) jj_scanpos = xsp;
        if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_23() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_58()) jj_scanpos = xsp;
        if (jj_scan_token(LONG_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_22() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_57()) jj_scanpos = xsp;
        if (jj_scan_token(INTEGER_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_29() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_64()) jj_scanpos = xsp;
        if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_28() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_63()) jj_scanpos = xsp;
        if (jj_scan_token(LONG_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_27() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_62()) jj_scanpos = xsp;
        if (jj_scan_token(INTEGER_LITERAL)) return true;
        return false;
    }

    private boolean jj_3_5() {
        if (jj_3R_26()) return true;
        return false;
    }

    private boolean jj_3_4() {
        if (jj_3R_25()) return true;
        if (jj_scan_token(DOT)) return true;
        return false;
    }

    private boolean jj_3_3() {
        if (jj_3R_26()) return true;
        return false;
    }

    private boolean jj_3_26() {
        if (jj_3R_61()) return true;
        return false;
    }

    private boolean jj_3_1() {
        if (jj_scan_token(OPENPAREN)) return true;
        if (jj_3R_24()) return true;
        return false;
    }

    private boolean jj_3_25() {
        if (jj_3R_60()) return true;
        return false;
    }

    private boolean jj_3R_72() {
        if (jj_scan_token(ESC_IDENTIFIER)) return true;
        return false;
    }

    private boolean jj_3_2() {
        if (jj_3R_25()) return true;
        if (jj_scan_token(DOT)) return true;
        return false;
    }

    private boolean jj_3R_71() {
        if (jj_scan_token(IDENTIFIER)) return true;
        return false;
    }

    private boolean jj_3R_25() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_71()) {
            jj_scanpos = xsp;
            if (jj_3R_72()) return true;
        }
        return false;
    }

    /**
     * Generated Token Manager.
     */
    public SqlParserTokenManager token_source;
    SimpleCharStream jj_input_stream;
    /**
     * Current token.
     */
    public Token token;
    /**
     * Next token.
     */
    public Token jj_nt;
    private int jj_ntk;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    private int jj_gen;
    final private int[] jj_la1 = new int[156];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static private int[] jj_la1_2;
    static private int[] jj_la1_3;

    static {
        jj_la1_init_0();
        jj_la1_init_1();
        jj_la1_init_2();
        jj_la1_init_3();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[]{0xe020, 0x1, 0x40080, 0x0, 0x0, 0x0, 0x200000, 0x80000000, 0x0, 0x4000, 0x1, 0x0, 0x200000, 0x80000000, 0x0, 0x0, 0x1, 0x0, 0x200000, 0x80000000, 0x0, 0x1, 0x0, 0x1000, 0x0, 0x0, 0x0, 0x0, 0x10000000, 0x0, 0x0, 0x10000, 0x0, 0x0, 0x10000000, 0x0, 0x0, 0x10000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40080, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0xc000400, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x20200, 0x20200, 0x0, 0x0, 0x0, 0x20200, 0x20200, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40000000, 0x100, 0x0, 0x100, 0x0, 0x0, 0x0, 0x0, 0x11400800, 0x0, 0x11000000, 0x10000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x13c00800, 0x0, 0x13000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10000000, 0x11000000, 0x10000000, 0x0, 0x0, 0x0, 0x11400800, 0x11000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[]{0xc8441, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x4000, 0x0, 0x0, 0x100, 0x0, 0x0, 0x4000, 0x100, 0x0, 0x100, 0x0, 0x0, 0x4000, 0x0, 0x10, 0x0, 0x10, 0x0, 0x0, 0x20001, 0x0, 0x100200, 0x100200, 0x0, 0x0, 0x0, 0x0, 0x100200, 0x100200, 0x0, 0x300000, 0x0, 0xc0000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x400000, 0x400000, 0x0, 0x400000, 0x400000, 0x0, 0x0, 0x0, 0x24, 0x0, 0x1000000, 0x1000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6000000, 0x6000000, 0x0, 0x0, 0x0, 0x6000000, 0x6000000, 0x1000000, 0x1000000, 0x1000000, 0x1000000, 0x0, 0x0, 0x100, 0x0, 0x100, 0x0, 0x0, 0x0, 0x0, 0x100, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf8000000, 0x0, 0x0, 0x0, 0x100, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8,};
    }

    private static void jj_la1_init_2() {
        jj_la1_2 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3000000, 0x0, 0x0, 0x0, 0x3000000, 0x0, 0x3000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3000000, 0x0, 0x0, 0xe3000000, 0x0, 0xe3000000, 0xe3000000, 0x0, 0x0, 0x3000000, 0x3000000, 0x0, 0x3000000, 0x3000000, 0x0, 0x0, 0xe301b000, 0x0, 0x3000000, 0x0, 0x3000000, 0x3000000, 0x0, 0xe3000000, 0x3000000, 0x0, 0x3000000, 0x3000000, 0x0, 0x0, 0x0, 0x1b000, 0x0, 0x0, 0x0, 0x0, 0x1b000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3000000, 0x0, 0x3000000, 0x0, 0x0, 0x3000000, 0x0, 0x3000000, 0x0, 0x0, 0x0, 0x0, 0x3000000, 0x0, 0x0, 0x0, 0x0, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20020, 0x0, 0xfe0fff, 0x3000000, 0x0, 0x10000000, 0x3000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18000, 0x3000000, 0x0, 0x0, 0x0, 0x0, 0x18000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18000, 0x0, 0xe001b000, 0x0, 0x0, 0x0, 0x1b000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18000, 0x0,};
    }

    private static void jj_la1_init_3() {
        jj_la1_3 = new int[]{0x0, 0x20, 0x0, 0x20000, 0x40000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x20000, 0x0, 0x0, 0x0, 0x20000, 0x20, 0x20000, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x20000, 0x40000, 0x20000, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x2000002, 0x20000000, 0x2000002, 0x2000002, 0x0, 0x20000000, 0x200002, 0x200002, 0x20000000, 0x200002, 0x200002, 0x20000000, 0x1000000, 0x2000002, 0x0, 0x200000, 0x0, 0x0, 0x0, 0x20000000, 0x2, 0x0, 0x20000000, 0x0, 0x0, 0x1000000, 0x1000000, 0x1000000, 0x2000002, 0x20000000, 0x1000000, 0x1000000, 0x1000000, 0x2000002, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000, 0x0, 0x20000, 0x10000000, 0x40, 0x10000000, 0x1002fe00, 0x0, 0x2fe00, 0x0, 0x40000040, 0x40000040, 0x0, 0x20000, 0x20000, 0x20000000, 0x20000, 0x20000, 0x0, 0x20000, 0x0, 0x0, 0x23e00, 0x1000fe00, 0x0, 0xfe00, 0x1000000, 0x1000000, 0x1000000, 0x1800000, 0x1800000, 0x2000002, 0x20004, 0x2fe00, 0x1000000, 0x1000000, 0x1000000, 0x2000002, 0x4, 0x0, 0xfe00, 0x0, 0x10000000, 0x40, 0x10000000, 0x2fe00, 0xfe00, 0x1000000, 0x1000000, 0x1000000, 0x2000002, 0x4, 0x3000002, 0x1000000, 0x1000000, 0x1000000, 0x2000002, 0x20000000, 0x1000000, 0x1000000, 0x1000000, 0x1800000, 0x1800000, 0x2000002, 0x4,};
    }

    final private JJCalls[] jj_2_rtns = new JJCalls[35];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    /**
     * Constructor with InputStream.
     */
    public SqlParser(java.io.InputStream stream) {
        this(stream, null);
    }

    /**
     * Constructor with InputStream and supplied encoding
     */
    public SqlParser(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new SqlParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 156; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 156; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Constructor.
     */
    public SqlParser(java.io.Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new SqlParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 156; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 156; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Constructor with generated Token Manager.
     */
    public SqlParser(SqlParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 156; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    public void ReInit(SqlParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 156; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    static private final class LookaheadSuccess extends java.lang.Error {
    }

    final private LookaheadSuccess jj_ls = new LookaheadSuccess();

    private boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null) jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
        return false;
    }


    /**
     * Get the next Token.
     */
    final public Token getNextToken() {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /**
     * Get the specific Token.
     */
    final public Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100) return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++) {
                jj_expentry[i] = jj_lasttokens[i];
            }
            jj_entries_loop:
            for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext(); ) {
                int[] oldentry = (int[]) (it.next());
                if (oldentry.length == jj_expentry.length) {
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            continue jj_entries_loop;
                        }
                    }
                    jj_expentries.add(jj_expentry);
                    break jj_entries_loop;
                }
            }
            if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    /**
     * Generate ParseException.
     */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[127];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 156; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & (1 << j)) != 0) {
                        la1tokens[64 + j] = true;
                    }
                    if ((jj_la1_3[i] & (1 << j)) != 0) {
                        la1tokens[96 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 127; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /**
     * Enable tracing.
     */
    final public void enable_tracing() {
    }

    /**
     * Disable tracing.
     */
    final public void disable_tracing() {
    }

    private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 35; i++) {
            try {
                JJCalls p = jj_2_rtns[i];
                do {
                    if (p.gen > jj_gen) {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i) {
                            case 0:
                                jj_3_1();
                                break;
                            case 1:
                                jj_3_2();
                                break;
                            case 2:
                                jj_3_3();
                                break;
                            case 3:
                                jj_3_4();
                                break;
                            case 4:
                                jj_3_5();
                                break;
                            case 5:
                                jj_3_6();
                                break;
                            case 6:
                                jj_3_7();
                                break;
                            case 7:
                                jj_3_8();
                                break;
                            case 8:
                                jj_3_9();
                                break;
                            case 9:
                                jj_3_10();
                                break;
                            case 10:
                                jj_3_11();
                                break;
                            case 11:
                                jj_3_12();
                                break;
                            case 12:
                                jj_3_13();
                                break;
                            case 13:
                                jj_3_14();
                                break;
                            case 14:
                                jj_3_15();
                                break;
                            case 15:
                                jj_3_16();
                                break;
                            case 16:
                                jj_3_17();
                                break;
                            case 17:
                                jj_3_18();
                                break;
                            case 18:
                                jj_3_19();
                                break;
                            case 19:
                                jj_3_20();
                                break;
                            case 20:
                                jj_3_21();
                                break;
                            case 21:
                                jj_3_22();
                                break;
                            case 22:
                                jj_3_23();
                                break;
                            case 23:
                                jj_3_24();
                                break;
                            case 24:
                                jj_3_25();
                                break;
                            case 25:
                                jj_3_26();
                                break;
                            case 26:
                                jj_3_27();
                                break;
                            case 27:
                                jj_3_28();
                                break;
                            case 28:
                                jj_3_29();
                                break;
                            case 29:
                                jj_3_30();
                                break;
                            case 30:
                                jj_3_31();
                                break;
                            case 31:
                                jj_3_32();
                                break;
                            case 32:
                                jj_3_33();
                                break;
                            case 33:
                                jj_3_34();
                                break;
                            case 34:
                                jj_3_35();
                                break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (LookaheadSuccess ls) {
            }
        }
        jj_rescan = false;
    }

    private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
