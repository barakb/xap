/*
 * Copyright (c) 2008-2016, GigaSpaces Technologies, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.gigaspaces.internal.server.space.operations;

import com.gigaspaces.client.ChangeException;
import com.gigaspaces.client.ChangeResult;
import com.gigaspaces.client.ChangedEntryDetails;
import com.gigaspaces.client.CustomChangeOperation;
import com.gigaspaces.client.FailedChangedEntryDetails;
import com.gigaspaces.client.mutators.SpaceEntryMutator;
import com.gigaspaces.internal.client.ChangeDetailedResultImpl;
import com.gigaspaces.internal.client.ChangeEntryDetailsImpl;
import com.gigaspaces.internal.client.ChangeResultImpl;
import com.gigaspaces.internal.client.FailedChangedEntryDetailsImpl;
import com.gigaspaces.internal.client.spaceproxy.operations.ChangeEntriesSpaceOperationRequest;
import com.gigaspaces.internal.client.spaceproxy.operations.ChangeEntriesSpaceOperationResult;
import com.gigaspaces.internal.metadata.ITypeDesc;
import com.gigaspaces.internal.server.space.SpaceImpl;
import com.gigaspaces.internal.server.storage.IEntryData;
import com.gigaspaces.lrmi.nio.IResponseContext;
import com.gigaspaces.lrmi.nio.ResponseContext;
import com.gigaspaces.security.authorities.SpaceAuthority.SpacePrivilege;
import com.j_spaces.core.ExtendedAnswerHolder;
import com.j_spaces.core.client.Modifiers;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * @author eitany
 * @since 9.1
 */
@com.gigaspaces.api.InternalApi
public class ChangeEntriesSpaceOperation
        extends AbstractSpaceOperation<ChangeEntriesSpaceOperationResult, ChangeEntriesSpaceOperationRequest> {

    @Override
    public void execute(ChangeEntriesSpaceOperationRequest request,
                        ChangeEntriesSpaceOperationResult result, SpaceImpl space,
                        boolean oneway) throws Exception {
        IResponseContext respContext = ResponseContext.getResponseContext();
        if (respContext != null)
            respContext.setInvokedFromNewRouter(true);

        SpacePrivilege requiredPrivilege = getRequiredPrivilege(request.getMutators());

        space.beginPacketOperation(true, request.getSpaceContext(), requiredPrivilege, request.getTemplatePacket());

        ExtendedAnswerHolder answerHolder =
                space.getEngine().change(request.getTemplatePacket(),
                        request.getTransaction(),
                        request.getLease(),
                        request.getTimeout(),
                        request.getSpaceContext(),
                        false /* fromReplication */,
                        true /* origin */,
                        request.getMutators(),
                        request.getModifiers(),
                        false);
        //Should be after the template has its type descriptor filled
        //TODO MU: (GS-10649)currently entryData does not contain the id if it is autogenerated, so we can't
        //rely on getting to id from the rejected/modified entry until we fix this. Since we only match by id at the moment
        //we can safely take the id from the template is it should match the updated entry
        Object uid = request.getTemplatePacket().getUID();
        boolean byId = (uid != null || (request.getTemplatePacket().getID() != null && (request.getTemplatePacket().getExtendedMatchCodes() == null && request.getTemplatePacket().getCustomQuery() == null)));
        if (byId)
            setResult(result, answerHolder, request.getModifiers(), uid);
        else
            setMultipleEntriesResult(result, answerHolder, request.getModifiers());
        if (Modifiers.contains(request.getModifiers(), Modifiers.LOG_SCANNED_ENTRIES_COUNT))
            result.setNumOfEntriesMatched(answerHolder.getNumOfEntriesMatched());
    }

    private static SpacePrivilege getRequiredPrivilege(
            Collection<SpaceEntryMutator> mutators) {
        for (SpaceEntryMutator spaceEntryMutator : mutators) {
            if (spaceEntryMutator instanceof CustomChangeOperation)
                return SpacePrivilege.EXECUTE;
        }

        return SpacePrivilege.WRITE;
    }

    @SuppressWarnings("unchecked")
    public static void setResult(ChangeEntriesSpaceOperationResult result,
                                 ExtendedAnswerHolder answerHolder, int modifiers, Object templateUid) {
        Throwable exception = answerHolder.getException();
        IEntryData modifiedEntryData = answerHolder.getModifiedEntryData();
        IEntryData rejectedEntry = answerHolder.getRejectedEntry();
        final boolean isDetailedResult = Modifiers.contains(modifiers, Modifiers.RETURN_DETAILED_CHANGE_RESULT);
        ChangeResult<?> resultImpl = null;
        if (modifiedEntryData != null) {
            if (isDetailedResult) {
                Object idValue = extractId(templateUid, modifiedEntryData);
                resultImpl = new ChangeDetailedResultImpl(new ChangeEntryDetailsImpl(modifiedEntryData.getSpaceTypeDescriptor().getTypeName(),
                        idValue,
                        modifiedEntryData.getVersion(),
                        answerHolder.getChangeResults()));
            } else {
                resultImpl = ChangeResultImpl.SINGLE;
            }
        } else if (rejectedEntry != null) {
            Object idValue = extractId(templateUid, rejectedEntry);
            FailedChangedEntryDetails failedChangeResult = new FailedChangedEntryDetailsImpl(rejectedEntry.getSpaceTypeDescriptor().getTypeName(),
                    idValue,
                    rejectedEntry.getVersion(),
                    exception);
            Collection<FailedChangedEntryDetails> entriesFailedToChange = Collections.singletonList(failedChangeResult);
            result.setExecutionException(new ChangeException("Failed changing entry in space - " + exception.getMessage(), Collections.EMPTY_LIST, entriesFailedToChange, Collections.EMPTY_LIST));
        } else if (exception != null) {
            result.setExecutionException(new ChangeException("Failed changing entry in space - " + exception.getMessage(), Collections.EMPTY_LIST, Collections.EMPTY_LIST, Collections.singletonList(exception)));
        } else {
            if (isDetailedResult)
                resultImpl = ChangeDetailedResultImpl.EMPTY;
            else
                resultImpl = ChangeResultImpl.EMPTY;
        }

        result.setChangeResult(resultImpl);
    }

    //build result for batch operation
    @SuppressWarnings("unchecked")
    public static void setMultipleEntriesResult(ChangeEntriesSpaceOperationResult result,
                                                ExtendedAnswerHolder answerHolder, int modifiers) {
        Throwable exception = answerHolder.getException();
        final boolean isDetailedResult = Modifiers.contains(modifiers, Modifiers.RETURN_DETAILED_CHANGE_RESULT);
        Collection<ChangedEntryDetails<?>> changedEntries = Collections.EMPTY_LIST;
        if (answerHolder.anyChangedEntriesForMultipleOperation() && isDetailedResult) {
            changedEntries = new ArrayList<ChangedEntryDetails<?>>(answerHolder.getModifiedEntriesData().size());
            for (int i = 0; i < answerHolder.getModifiedEntriesData().size(); i++) {
                IEntryData ed = answerHolder.getModifiedEntriesData().get(i);
                List<Object> results = answerHolder.getChangeResults() != null ? (List<Object>) answerHolder.getChangeResults().get(i) : null;
                changedEntries.add(new ChangeEntryDetailsImpl(ed.getSpaceTypeDescriptor().getTypeName(),
                        extractId(answerHolder.getModifiedEntriesUids().get(i), ed),
                        ed.getVersion(), results));
            }
        }
        Collection<FailedChangedEntryDetails> rejectedEntries = Collections.EMPTY_LIST;
        if (answerHolder.anyRejectedEntriesForMultipleOperation()) {
            rejectedEntries = new ArrayList<FailedChangedEntryDetails>(answerHolder.getRejectedEntries().size());
            for (int i = 0; i < answerHolder.getRejectedEntries().size(); i++) {
                IEntryData ed = answerHolder.getRejectedEntries().get(i);
                rejectedEntries.add(new FailedChangedEntryDetailsImpl(ed.getSpaceTypeDescriptor().getTypeName(),
                        extractId(answerHolder.getRejectedEntriesUids().get(i), ed),
                        ed.getVersion(),
                        answerHolder.getRejectedCause().get(i)));
            }
        }
        ChangeResult<?> resultImpl = null;
        if (exception != null) {
            if (isDetailedResult)
                result.setExecutionException(new ChangeException(" Failed changing entry in space  -  " + exception.getMessage(), changedEntries, rejectedEntries, Collections.singletonList(exception)));
            else
                result.setExecutionException(new ChangeException("Failed changing entry in space  - " + exception.getMessage(), answerHolder.getNumChangedEntriesForMultipleOperation(), rejectedEntries, Collections.singletonList(exception)));

        } else if (!rejectedEntries.isEmpty()) {
            if (isDetailedResult)
                result.setExecutionException(new ChangeException("Failed to change some entries in space  ", changedEntries, rejectedEntries, Collections.EMPTY_LIST));
            else
                result.setExecutionException(new ChangeException("Failed to change some entries in space  ", answerHolder.getNumChangedEntriesForMultipleOperation(), rejectedEntries, Collections.EMPTY_LIST));
        } else {
            if (answerHolder.anyChangedEntriesForMultipleOperation()) {
                if (isDetailedResult) {
                    resultImpl = new ChangeDetailedResultImpl(changedEntries);
                } else {
                    int size = answerHolder.getModifiedEntriesData().size();
                    resultImpl = size == 1 ? ChangeResultImpl.SINGLE : new ChangeResultImpl(size);
                }
            } else {
                if (isDetailedResult)
                    resultImpl = ChangeDetailedResultImpl.EMPTY;
                else
                    resultImpl = ChangeResultImpl.EMPTY;
            }
        }
        result.setChangeResult(resultImpl);
    }


    private static Object extractId(Object templateId, IEntryData entryData) {
        Object idValue = entryData.getPropertyValue(entryData.getSpaceTypeDescriptor().getIdPropertyName());
        //TODO MU: (GS-10649)work around, when using auto generated id sometimes the IEntryData does not contain the id, in our case
        //the matching is by id only so we can quite safely use the template id to fill in the missing id property. However this is risky
        //and may hide other problems if for example a different entry was changed for some reason, this should be removed if we change the
        //entry data to contain the id
        if (idValue == null && ((ITypeDesc) entryData.getSpaceTypeDescriptor()).isAutoGenerateId())
            idValue = templateId;
        return idValue;
    }

    @Override
    public String getLogName(ChangeEntriesSpaceOperationRequest request, ChangeEntriesSpaceOperationResult result) {
        return "change";
    }


}
